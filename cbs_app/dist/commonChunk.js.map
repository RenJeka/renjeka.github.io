{"version":3,"sources":["webpack:///./src/myHelperLib.js","webpack:///./src/generalClasses/table.class.js","webpack:///./src/generalClasses/form.class.js","webpack:///./src/img/arrow-d.svg","webpack:///./src/objectsClasses/books.class.js","webpack:///./src/objectsClasses/genres.class.js","webpack:///./src/objectsClasses/authors.class.js"],"names":["$","selector","document","querySelector","changeClass","event","eventElement","targetElement","classOpened","element","src","cssClass","image","parent","expandIcon","menuIcon","Image","parentNode","classList","add","appendChild","addEventListener","i","length","toggle","Table","currentTable","formObject","tableData","this","localStorageKey","getTableData","boundForm","currentForm","arrayOfObservers","sortMark","sortDirection","otherRowSelectHandler","selectedRowIndex","selectedObject","observers","forEach","push","observerUpdate","onclick","bind","rowSelectHandler","addRows","rowIndex","jsonObject","localStorage","getItem","JSON","parse","some","elem","sort","sortFunc1","undefined","dataInRow","numberOfRows","numberOfCells","arrayofRows","row","context","createElement","tBodies","j","cell","addInfoInRow","rows","cells","indexOfRow","object","addInfoInCell","indexOfCell","key","hasOwnProperty","toLowerCase","getTableColumnHead","innerHTML","dataset","objectKeyBind","parseInt","deleteRow","input","objectProperty","filter","trim","includes","value","console","log","callbackHandler","eventObject","returnedValue","target","tagName","cleanTable","fillTable","parentElement","fillForm","setClassToElement","dir","notify","applyingСlass","className","a","b","remove","Form","idName","dataArray","getLocalStorageKey","needAddToLocalStorege","window","lastFilledObject","dublicateKey","validate","fillObject","findDublicate","cleanInputs","addToDatabase","id","elements","accumulateValues","getObjectType","Book","Author","Genre","getID","hasAttribute","type","k","selectedOptions","getAttribute","Object","assign","boundId","boundElement","localName","style","display","flag","item","alert","counterOfInvalid","pattern","message","valid","search","required","newArray","setItem","stringify","warn","overwriteLocalStorage","splice","findObject","copiedObject","findIndex","currentId","postfix","currentElement","localStorageKeyBind","objectPropertyBind","arrayOfObjects","labels","fillInput","bindingKey","elementType","optionElement","fillingObject","module","exports"],"mappings":"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","file":"commonChunk.js","sourcesContent":["//  Моя вспомогательная библиотека. Тут находятся функции-помощники, чтобы не подключать JQuery.\r\nimport menuIcon from\"./img/arrow-d.svg\";\r\n/**\r\n * Функция захвата DOM-элемента\r\n * @param {string} selector Селектор, по которому необходимо вернуть элемент\r\n * @return {object} Первый найденный элемент DOM-дерева.\r\n */\r\nfunction $(selector) {\r\n\treturn document.querySelector(selector);\r\n}\r\n\r\n/**\r\n * Функция, которая меняет (переключает) указанные классы (в ...rest -параметре) указанного DOM-элемента.\r\n * @description С помощью CSS классов невозможно изменить стили родительского элемента. Для решении этого применяется данная функция\r\n * @param {string} event Событие, по которому функция меняет класс.\r\n * @param {object} eventElement Элемент, на котором происходит событие.\r\n * @param {object} targetElement Целевой элемент, чьи классы должны изменится\r\n * @param {...any} classOpened Классы, которые должны поменятся (rest-параметр)\r\n * @return {void} Ничего не возвращает\r\n */\r\nfunction changeClass(event, eventElement, targetElement, ...classOpened){\r\n\r\n\tlet expandIcon = addImage(eventElement, menuIcon, \"wrapper-logo-expand-icon\");\r\n\teventElement.addEventListener(event, () => {\r\n\t\tfor (let i = 0; i < classOpened.length; i++) {\r\n\t\t\ttargetElement.classList.toggle(classOpened[i])\r\n\t\t}\r\n\t\texpandIcon.classList.toggle(\"wrapper-logo-expand-icon-hide\");\r\n\t});\r\n\texpandIcon.addEventListener(event, () => {\r\n\t\tfor (let i = 0; i < classOpened.length; i++) {\r\n\t\t\ttargetElement.classList.toggle(classOpened[i])\r\n\t\t}\r\n\t\texpandIcon.classList.toggle(\"wrapper-logo-expand-icon-hide\");\r\n\t});\r\n}\r\n\r\n/**\r\n * Функция добавляет дополнительную иконку в раскрывающееся меню после указанного элемента\r\n * @param {object} element DOM-элемент, после которого необходимо добавить иконку\r\n * @param {string} src путь к иконке\r\n * @param {string} cssClass css класс, который необходимо применить к иконке\r\n * @description Необходимо добавить элемент в \"import\",чтобы иконка была в наличии.\r\n * @returns {object} Функция возвращает DOM-элемент -- настроенную иконку. (объект класса Image)\r\n */\r\nfunction addImage(element,src,cssClass) {\r\n\tlet image = new Image(),\r\n\t\tparent = element.parentNode;\r\n\timage.src = src;\r\n\timage.classList.add(cssClass);\r\n\tparent.appendChild(image);\r\n\r\n\treturn image;\r\n}\r\n\r\nexport {$, changeClass};","import { $ } from \"../myHelperLib\";\r\n\r\n/**\r\n * Класс для создания объекта \"Таблица\"\r\n * Объект таблица является Наблюдаемым объектом (Observable) \r\n */\r\nexport class Table{\r\n\r\n\t/**\r\n\t * Конструктор. Создает объект -- таблица, которая подвязывается под 1 HTML-таблицу\r\n\t * @param {String} currentTable CSS -селектор для нахождения нужной (связанной таблицы)\r\n\t * @param {object} formObject Объект формы, созданный классом \"Form\"\r\n\t * @param {Array} tableData -- Массив объектов, которыми будет заполнятся таблица\r\n\t */\r\n\tconstructor(currentTable,formObject,tableData){\r\n\r\n\t\t/**\r\n\t\t * Текущая (связанная DOM-таблица).\r\n\t\t */\r\n\t\tthis.currentTable = $(currentTable);\r\n\r\n\t\t/**\r\n\t\t * Текущий объект формы(связанная форма).\r\n\t\t */\r\n\t\tthis.formObject = formObject;\r\n\r\n\t\t/**\r\n\t\t * Ключ от localStorage, где хранится массив данных с объектами, которые представлены в данной таблице\r\n\t\t * @type {string}\r\n\t\t */\r\n\t\tthis.localStorageKey = formObject.localStorageKey\r\n\r\n\t\tif (tableData) {\r\n\t\t\t/**\r\n\t\t\t * Данные, которые заполняются в таблицу.\r\n\t\t\t */\r\n\t\t\tthis.tableData = tableData;\t\r\n\t\t}else if(this.getTableData()){\r\n\t\t\tthis.tableData = this.getTableData();\r\n\t\t}else{\r\n\t\t\tthis.tableData = [];\r\n\t\t}\r\n\t\t\r\n\r\n\t\t/**\t\r\n\t\t * Привязанная форма под данную таблицу. Объект класса \"Form\".\r\n\t\t * @type {object}\r\n\t\t */\r\n\t\tthis.boundForm = formObject.currentForm;\r\n\r\n\t\t/**\t\r\n\t\t * Список подписчиков (паттерн Observer)\r\n\t\t * @type {Array}\r\n\t\t */\r\n\t\tthis.arrayOfObservers = [];\r\n\r\n\t\t/**\r\n\t\t * Свойство, которое содержит значение, по которому будут отсортированны данные в таблице\r\n\t\t * @type {string}\r\n\t\t */\r\n\t\tthis.sortMark;\r\n\r\n\t\t/**\r\n\t\t * Свойство, которое содержит направление сортировки данных в таблице. (прямое или обратное)\r\n\t\t * @type {boolean}\r\n\t\t */\r\n\t\tthis.sortDirection = true;\r\n\r\n\t\t/**\t\r\n\t\t * Свойство, которое содержит пользовательский обработчик событий (при клике на строку таблицы)\r\n\t\t * @type {function}\r\n\t\t */\r\n\t\tthis.otherRowSelectHandler;\r\n\r\n\t\t/**\r\n\t\t * Индекс строки, которая в данный момент выделена пользователем в таблице. (DOM-элемент)\r\n\t\t * @type {number}\r\n\t\t */\r\n\t\tthis.selectedRowIndex = null;\r\n\r\n\t\t/**\r\n\t\t * Объект, который привязан к текущей выделенной строку таблицы таблице\r\n\t\t * @type {object}\r\n\t\t */\r\n\t\tthis.selectedObject;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Метод добавляет подписчика в массив подписчиков (паттерн Observer)\r\n\t * @param {object} observers (rest-параметр) Подписчики (наблюдатели) за изменениями\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\taddObservers(...observers){\r\n\t\tobservers.forEach(element => {\r\n\t\t\tthis.arrayOfObservers.push(element);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Метод - уведомление подписчиков об изменениях (паттерн Observer). Этот метод создаваля для синхронизации параметра \"tableData\" и обработчика выбора строки \"rowSelectHandler\". Здесь объект класа Table ОДНОВРЕМЕННО и ИЗДАТЕЛЬ и ПОДПИСЧИК.\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\tnotify(){\r\n\t\tthis.arrayOfObservers.forEach(element => {\r\n\t\t\telement.observerUpdate({currentTable: this.currentTable, tableData: this.tableData, selectedObject: this.selectedObject})\r\n\t\t});\r\n\t\t// console.log(`selectedObject = `, this.selectedObject);\r\n\t}\r\n\t\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод update паттерна Observer\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\tobserverUpdate(){\r\n\t\tif (this.otherRowSelectHandler) {\r\n\t\t\tthis.currentTable.onclick = this.otherRowSelectHandler.bind(this);\r\n\t\t}else{\r\n\t\t\tthis.currentTable.onclick = this.rowSelectHandler.bind(this);\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет указанную таблицу, взяв данные с LocalStorage по ключу, либо указанным ранее массивом объектов.\r\n\t * @return {void} Возвращает массив с данными, которыми была заполнена таблица.\r\n\t */\r\n\tfillTable(sortMark,sortDirection) {\r\n\t\r\n\t\tif (sortMark) {\r\n\t\t\tthis.sortMark = sortMark;\r\n\t\t}\r\n\t\tif (sortDirection) {\r\n\t\t\tthis.sortDirection = sortDirection;\r\n\t\t}\r\n\t\t\r\n\t\t// Если у нас есть связанная таблица и готовый массив с данными для заполнения таблицы\r\n\t\tif (this.currentTable && this.tableData) {\r\n\t\t\t\r\n\t\t\t// Заполняем таблицу данными\r\n\t\t\tfor (let i = 0; i < this.tableData.length; i++) { // ? ForEach? \r\n\t\t\t\tthis.addRows(this.tableData[i]).rowIndex; \r\n\t\t\t}\r\n\r\n\t\t\t//Возвращаем массив, которым заполнили таблицу\r\n\t\t\treturn this.tableData;\r\n\r\n\t\t// Если у нас есть связанная таблица и ключ от localStorage\r\n\t\t}else if (this.currentTable && this.localStorageKey) {\r\n\r\n\t\t\t// Достаем данные из localStorage\r\n\t\t\tthis.tableData = this.getTableData();\r\n\r\n\t\t\t// Проверка на наличие данных в localStorage //TODO Проверить, правильная ли проверка\r\n\t\t\tif (this.tableData == false) {\r\n\r\n\t\t\t\t// Если в localStorage пустой массив -- возвращаем false\r\n\t\t\t\treturn false; \r\n\t\t\t}\r\n\r\n\t\t\t// Заполняем таблицу данными\r\n\t\t\tfor (let i = 0; i < this.tableData.length; i++) { // ? ForEach? \r\n\t\t\t\tthis.addRows(this.tableData[i]).rowIndex; \r\n\t\t\t}\r\n\r\n\t\t\t//Возвращаем массив, которым заполнили таблицу\r\n\t\t\treturn this.tableData;\r\n\r\n\t\t}else{\r\n\r\n\t\t\t// Если таблица не подвязана -- выброс исключения\r\n\t\t\tif (this.currentTable == false) {\r\n\t\t\t\tthrow `Не найдена связанная HTML-таблица. Пожалуйста добавьте HTML-таблицу в свойство ${this}.currentTable `;\r\n\r\n\t\t\t// Если у нас нет ни массива с данными, ни ключа localStorage -- выброс исключения\r\n\t\t\t}else if (this.localStorageKey == false && this.tableData == false) {\r\n\t\t\t\t\r\n\t\t\t\tthrow `Не найдены данные для заполнения HTML-таблицы. Пожалуйста добавте данные. Если у вас массив с данными -- добавьте этот массив в свойство  ${this}.tableData, если у вас данные в LocalStorage -- добавте ключ к данным в свойство ${this}.localStorageKey`;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод позволяет получить данные с LocalStorage для заполнения таблицы.  \r\n\t * @return {Object} Возвращает массив объектов, которым можно заполнить таблицу, или false, если не смог найти его в localStorage.\r\n\t */\r\n\tgetTableData() { \r\n\r\n\t\tlet jsonObject = localStorage.getItem(this.localStorageKey);\r\n\r\n\t\t// Если есть JSON-данные по переданному ключу — тогда возвращаем подготовленные данные, если JSON не найден — возвращаем false.\r\n\t\tif (jsonObject) {\r\n\r\n\t\t\t// Парсим данные из localStorage. Получаем массив с объектами\r\n\t\t\tjsonObject = JSON.parse(jsonObject);\r\n\r\n\t\t\t// Если поле для сортировки \"this.sortMark\" соответствует свойству в объекте\r\n\t\t\tif (jsonObject.some((elem)=>elem[this.sortMark])) {\r\n\r\n\t\t\t\t//Возвращаем отсортированный массив по заранее заданной функции\r\n\t\t\t\treturn jsonObject.sort(this.sortFunc1.bind(this)) \r\n\r\n\t\t\t// Если нет значения для сортировки \"this.sortMark\" — Возвращаем неотсортированный массив.\r\n\t\t\t}else if(this.sortMark == undefined){\r\n\t\t\t\treturn jsonObject;\r\n\r\n\t\t\t// Если значения для сортировки \"this.sortMark\" не верное — выбрасываем исключение. \r\n\t\t\t}else{\r\n\t\t\t\tthrow \"Значение, переданное для сортировки — не верное. Такого свойства у объекта нет.\"\r\n\t\t\t}\r\n\r\n\t\t}else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который добавляет ряды с ячейками в таблицу\r\n\t * @todo реализовать метод без замыкания (без внутреней функции)\r\n\t * @param {object} dataInRow Данные для 1 строки (1 объект)\t \r\n\t * @param {Number} numberOfRows Кол-во рядов (по умолчанию = 1)\r\n\t * @param {Number} numberOfCells Кол-во ячеек в ряде (По умолчанию высчитывается по кол-ву ячеек в заголовке (thead))\r\n\t * @return {arrayofRows} Возвращает созданный массив строк (либо 1 строку) с данными.\r\n\t */\r\n\taddRows(dataInRow, numberOfRows = 1, numberOfCells) {\r\n\t\t\r\n\t\tlet arrayofRows = [], // Массив будущих строк\r\n\t\t\trow; // Текущая строка\r\n\r\n\t\t// Эта функция собственно и добавляет ряд, ячейки и текст в таблицу. Принимает контекст, и возвращает массив с созданными строками\r\n\t\tfunction add(context) {\r\n\t\t\t\r\n\t\t\t// Цикл добавляеи по 1-й строке то кол-во, которое мы укажем (numberOfRows)\r\n\t\t\tfor (let i = 0; i < numberOfRows; i++) {\r\n\r\n\t\t\t\trow = document.createElement(\"tr\")\r\n\t\t\t\tcontext.currentTable.tBodies[0].appendChild(row)\r\n\r\n\t\t\t\t// Цикл добавляет по 1-й ячейке то кол-во, которое мы укажем (numberOfCells)\r\n\t\t\t\tfor (let j = 0; j < numberOfCells; j++) {\r\n\r\n\t\t\t\t\tlet cell = document.createElement(\"td\")\r\n\t\t\t\t\trow.appendChild(cell)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tarrayofRows.push(row);\r\n\t\t\t\t\r\n\t\t\t\tif (dataInRow) {\r\n\t\t\t\t\tcontext.addInfoInRow(row.rowIndex, dataInRow);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn arrayofRows;\r\n\t\t}\r\n\r\n\t\t// Проверка на наличие аргумента \"numberOfCells\", если его нет— за количестко ячеек высчитывается из количества ячеек первого ряда (из \"thead\");\r\n\t\tif (numberOfCells == undefined) {\r\n\t\t\tnumberOfCells = this.currentTable.rows[0].cells.length;\r\n\t\t}\r\n\r\n\t\t// Этот способ будет использоваться чаще всего и возвращать 1 созданный ряд с данными.\r\n\t\tif (numberOfRows == 1) {\r\n\r\n\t\t\tarrayofRows = add(this) // ? return add(this)[0] -- попробовать вернуть это\r\n\t\t\treturn arrayofRows[0];\r\n\t\t}\r\n\t\treturn add(this);\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * метод, который заполняет ряд таблицы. Использует метод \"addInfoInCell\", который заполняет каждую ячейку\r\n\t * @param {Number} indexOfRow Индекс ряда в таблице, который будет заполнятся данными \r\n\t * @param {Object} object Объект с данными для заполнения ряда. \r\n\t * @return {void} Ничего не возвращает\r\n\t*/\r\n\taddInfoInRow(indexOfRow, object) {\r\n\r\n\t\tfor (let i = 0; i < this.currentTable.rows[indexOfRow].cells.length; i++) {\r\n\t\t\tthis.addInfoInCell(object, indexOfRow, i)\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет одну указанную ячейку в указанном ряде таблицы. Нужен для работы метода addInfoInRow\r\n\t * @param {Object} object Объект с данными для заполнения ячейки.\r\n\t * @param {Number} indexOfRow Индекс ряда, в котором находится нужная для заполнения ячейка\r\n\t * @param {Number} indexOfCell Индекс ячейки, которая будет заполнятся.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\taddInfoInCell(object, indexOfRow, indexOfCell) {\r\n\r\n\t\tfor (const key in object) {\r\n\t\t\tif (object.hasOwnProperty(key)) {\r\n\r\n\t\t\t\t// Если ключ объекта равняется тому, что вернул метот \"getTableColumnHead\" — значение из объекта заполняется в заранее заданную ячейку\r\n\t\t\t\tif (key.toLowerCase() === this.getTableColumnHead(indexOfCell).toLowerCase()){\r\n\r\n\t\t\t\t\tthis.currentTable.rows[indexOfRow].cells[indexOfCell].innerHTML = object[key];\r\n\r\n\t\t\t\t\t// Возвращаем заполненную ячейку\r\n\t\t\t\t\treturn this.currentTable.rows[indexOfRow].cells[indexOfCell]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод вычисляет, какой заголовок находиться над указанной ячейкой (Заголовок колонки). Нужен для работы метода \"addInfoInCell\"\r\n\t * @param {Number} indexOfCell Индекс ячейки, у которой необходимо узнать заголовок.\r\n\t * @return {String} Возвращает название заголовка над ячейкой.\r\n\t * @see addInfoInCell\r\n\t */\r\n\tgetTableColumnHead(indexOfCell) {\r\n\r\n\t\t// Получаем значение из атрибута \"data-object-key-bind\" в заголовочной ячейки\r\n\t\tlet nameOfTableHead = this.currentTable.rows[0].cells[indexOfCell].dataset.objectKeyBind;\r\n\t\treturn nameOfTableHead;\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод полностью очищает конкретный ряд либо таблицу целиком\r\n\t * @param {number} indexOfRow Индекс строки, которую нужно удалить. Если параметр отсутствует --таблица очистится полностью.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tcleanTable(indexOfRow){\r\n\r\n\t\tindexOfRow = parseInt(indexOfRow);\r\n\r\n\t\tif (indexOfRow) {\r\n\t\t\t// Проверка, правильно ли введен индекс строки\r\n\t\t\tif (indexOfRow <= this.currentTable.rows.length -1  && indexOfRow >= 0) {\r\n\r\n\t\t\t\t// Удаляем строку по индексу \"indexOfRow\"\r\n\t\t\t\tthis.currentTable.deleteRow(indexOfRow)\r\n\t\t\t}else{\r\n\t\t\t\tthrow \"Невозможно удалить строку. Такой строки не существует. Проверьте правильность передаваемого в параметр значения.\"\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// Запускаем цикл на иттераций равную кол-во строк в таблице. Каждый раз удаляем последнюю строку.\r\n\t\t\twhile (this.currentTable.rows.length > 1) {\r\n\t\t\t\tthis.currentTable.deleteRow(this.currentTable.rows.length - 1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод поиска. Фильтрует массив по значению input.value, и возвращает его.\r\n\t * @param {object} input Элемент, в который вводится фильтрирующее значение.\r\n\t * @param {string} objectProperty Имя свойства объекта, по которому будет происходить фильтрация.\r\n\t * @return {Array} Возвращает отфильтнованный массив либо false, если массив не удалось найти.\r\n\t */\r\n\tsearch(input, objectProperty){\r\n\t\tlet tempVariable;\r\n\t\tthis.tableData = this.getTableData();\r\n\r\n\t\tif(this.tableData){\r\n\r\n\t\t\ttempVariable = this.tableData.filter(element => {\r\n\r\n\t\t\t\t// Переводим значение свойства объекта в нижний регистр \r\n\t\t\t\tlet tempProperty = element[objectProperty].trim().toLowerCase();\r\n\t\t\t\t// Если \"tempProperty\" содержит то, что мы ввели в \"input\" -- значит это искомое значение.\r\n\t\t\t\treturn tempProperty.includes(input.value.trim().toLowerCase());\r\n\t\t\t});\r\n\t\t\treturn tempVariable;\r\n\t\t\t  \r\n\t\t}else{\r\n\t\t\tconsole.log (\"Не удалось найти массив с данными\")\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод запускает обработчик события по клику на строку. Можно подвесить свой обработчик (callbackHandler)\r\n\t * @param {Function} callbackHandler Функция, которая ставится в качестве обработчика на нажатие по таблице. (По умолчанию this.rowSelectHandler)\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\ttableClickHandler(callbackHandler){\r\n\r\n\t\tthis.otherRowSelectHandler = callbackHandler;\r\n\r\n\t\tif (this.otherRowSelectHandler) {\r\n\t\t\tthis.currentTable.onclick = this.otherRowSelectHandler.bind(this);\r\n\t\t}else{\r\n\t\t\tthis.currentTable.onclick = this.rowSelectHandler.bind(this);\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод обрабатывает клик по строке. Его задача отсортировать таблицу, если клик был по заголовку, или вернуть строку, если клик был по \"не заголовочной\" строке.\r\n\t * @todo Ножна ли тут переменная \"returnedValue\" ?\r\n\t * @param {object} eventObject Объект события, который передается при клике.\r\n\t * @return {object} Возвращщает массив с данными после сортировки, либо объект, на который кликнул пользователь.\r\n\t */\r\n\trowSelectHandler(eventObject){\r\n\r\n\t\tlet returnedValue; // Значение, которое возвращает этот метод.\r\n\r\n\t\t\r\n\t\tthis.sortMark = eventObject.target.dataset.objectKeyBind; // Записываем название свойства для сортировки\r\n\t\t\t\r\n\t\t// Проверка, если есть атрибут \"objectKeyBind\" у HTML элемента -- сортируем таблицу\r\n\t\tif (this.sortMark && eventObject.target.tagName == \"TH\") {\r\n\r\n\t\t\tthis.sortDirection = !this.sortDirection;\r\n\t\t\t\r\n\t\t\t// Сортируем текущие данные. (Учитывая потерю контекста)\r\n\t\t\tthis.tableData.sort(this.sortFunc1.bind(this));\r\n\r\n\t\t\t// Очищаем всю таблицу\r\n\t\t\tthis.cleanTable();\r\n\r\n\t\t\t// Заполняе новыми значениями (с учетом сортировки)\r\n\t\t\treturnedValue = this.fillTable();\r\n\t\t\tthis.tableData = returnedValue;\r\n\r\n\t\t\tthis.selectedRowIndex = null;\r\n\t\t\tthis.selectedObject = null;\r\n\r\n\t\t// Если пользователь кликнул по строке с данными -- находим индекс строки и возвращаем объект с массива объектов (по этому индексу)\r\n\t\t}else if(eventObject.target.tagName == \"TD\"){\r\n\r\n\t\t\tthis.selectedRowIndex = eventObject.target.parentElement.rowIndex; // Записываем индекс выделенной строки\r\n\r\n\t\t\treturnedValue = this.tableData[this.selectedRowIndex -1];\r\n\t\t\tthis.selectedObject = returnedValue;\r\n\t\t\tthis.formObject.fillForm(this.selectedObject)\r\n\t\t\tthis.setClassToElement(this.currentTable.rows[this.selectedRowIndex], \"row-selected\")\r\n\t\t\t\r\n\t\t\tconsole.log(`selectedObject =  `, this.selectedObject);\r\n\t\t\tconsole.dir(`this.selectedRowIndex = ${this.selectedRowIndex} `);\r\n\t\t}\r\n\r\n\t\t// по окончанию метода запускаем метод паттерна \"observer\" -- notify() чтобы обновить все данные.\r\n\t\tthis.notify();\r\n\r\n\t\treturn returnedValue;\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который проходится по таблице и применяет стиль к 1 конкретному ряду (строке).\r\n\t * @todo Как установить правильно класс элементу\r\n\t * @param {object} row Ряд к которому необходимо применить клас\r\n\t * @param {string} applyingСlass css клас, который нужно применить к ряду.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tsetClassToElement(row, applyingСlass){\r\n\t\tfor (let i = 0; i < this.currentTable.rows.length ; i++) {\r\n\t\t\tthis.currentTable.rows[i].className = \"\";\r\n\t\t\tif (this.currentTable.rows[i] == row) {\r\n\t\t\t\tthis.currentTable.rows[i].className = applyingСlass;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который передается в сортировку массива. Сортирует значения по возрастанию, либо по убыванию в зависимости от значения \"this.sortDirection\".\r\n\t * @param {object} a Первый параметр для сравнения со вторым\r\n\t * @param {object} b Второй параметр для сравнения с первым.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tsortFunc1(a, b) { \r\n\t\t\r\n\t\tif (this.sortDirection) {\r\n\t\t\tif (a[this.sortMark] >  b[this.sortMark]) return 1; // если первое значение больше второго\r\n\t\t\tif (a[this.sortMark] == b[this.sortMark]) return 0; // если равны\r\n\t\t\tif (a[this.sortMark] <  b[this.sortMark]) return -1; // если первое значение меньше второго\r\n\t\t}else{\r\n\t\t\tif (a[this.sortMark] <  b[this.sortMark]) return 1; \r\n\t\t\tif (a[this.sortMark] == b[this.sortMark]) return 0;\r\n\t\t\tif (a[this.sortMark] >  b[this.sortMark]) return -1;\r\n\t\t}\t\r\n\t}\r\n\t\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод обнуляет выделенную строку в таблице и в форме\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tnullifySelection(){\r\n\r\n\t\tif (this.selectedRowIndex != null && this.currentTable.rows[this.selectedRowIndex]) {\r\n\r\n\t\t\tthis.currentTable.rows[this.selectedRowIndex].classList.remove(\"row-selected\");\r\n\t\t}\r\n\r\n\t\tthis.formObject.selectedObject = null;\r\n\t\tthis.selectedRowIndex = null;\r\n\t\tthis.selectedObject = null;\r\n\t}\r\n}","import { Book} from '../objectsClasses/books.class';\r\nimport { Genre } from '../objectsClasses/genres.class';\r\nimport { Author } from '../objectsClasses/authors.class';\r\n\r\n/**\r\n * Класс для создания объекта \"Форма\"\r\n */\r\nexport class Form{\r\n\r\n\t/**\r\n\t * Конструктор класса \"Form\". Создает объект -- Форма, который подвязывается под под 1 HTML -форму.\r\n\t * @param {object} currentForm  Текущая <HTML>-форма, которая привязывается к данному объекту\r\n\t * @param {String} idName название ID для идентификации каждого объекта\r\n\t * @param {Array} dataArray (не обязательный) Массив данных, (набор объектов, что заполняется в форме). По умолчанию данные записываются в  localStorage.\r\n\t */\r\n\tconstructor(currentForm, idName, dataArray){\r\n\r\n\t\t/**\r\n\t\t * Текущая <HTML>-форма, которая привязывается к данному объекту\r\n\t\t */\r\n\t\tthis.currentForm = currentForm;\r\n\r\n\t\t/**\r\n\t\t * название ID для идентификации каждого объекта\r\n\t\t */\r\n\t\tthis.idName = idName;\r\n\r\n\t\t/**\r\n\t\t * (не обязательный) Массив данных, (набор объектов, что заполняется в форме). По умолчанию данные записываются в  localStorage.\r\n\t\t */\r\n\t\tthis.dataArray = [];\r\n\r\n\t\t/**\t\r\n\t\t * Ключ от localStorage, где хранится массив данных с объектами, которые которые обрабатывает данная форма.\r\n\t\t */\r\n\t\tthis.localStorageKey = this.getLocalStorageKey(\"-library\");\r\n\r\n\t\t/**\t\r\n\t\t * Нужно ли добавлять данные в LocalStorege (true -нужно, false -не нужно)\r\n\t\t */\r\n\t\tthis.needAddToLocalStorege = true;\r\n\r\n\t\t// TODO Как сделать так, чтобы объекты 2 разных классов знали друг о друге сразу, через конструктор. (И нужно ли вообще это?)\r\n\t\t// this.tableObject = tableObject;\r\n\t\t// this.tableObject;\r\n\r\n\t\tif (dataArray) {\r\n\t\t\tthis.dataArray = dataArray;\r\n\t\t\tthis.needAddToLocalStorege = false;\r\n\r\n\t\t}else if(window.localStorage.getItem(this.localStorageKey)){\r\n\t\t\tthis.dataArray = JSON.parse(window.localStorage.getItem(this.localStorageKey));\r\n\t\t}\r\n\t\t/**\t\r\n\t\t * Последний (текущий) объект, который заполнялся.\r\n\t\t */\r\n\t\tthis.lastFilledObject = {}; \r\n\r\n\t\t/**\t\r\n\t\t * Объект, который в текущий момент выбран в таблице.\r\n\t\t */\r\n\t\tthis.selectedObject;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * @param {object} Принимает объект с 4 свойсвами (свойства объекта класса Table) : currentTable - текущая таблица, tableData - текущий массив, которым заполнена таблица, selectedObject - текущий выбранный объект в таблице\r\n\t * Метод подписчика, обновляет данные \"this.selectedObject\"\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tobserverUpdate({currentTable, tableData, selectedObject}){\r\n\t\tthis.selectedObject = selectedObject\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Обработчик событий при нажатии на кнопку добавления объекта в базу данных. Берет с формы данные и записывает в базу данных.\r\n\t * @param {string} dublicateKey Ключ, по которому будет происходить поиск дубликатов (по умолчанию дубликатом считается объект с таким-же ID)\r\n\t * @return {object} Возвращает заполненный объект;\r\n\t */\r\n\taddButtonHandler(dublicateKey = this.idName) {\r\n\r\n\t\t// let isDatabaseCreated = localStorage.getItem(this.localStorageKey); // Переменная, которая указывает, создана ли база данных. \r\n\r\n\t\t// Проверка валидации. Если валидация вернула \"false\" — то закончить выполнение текущего метода\r\n\t\tif (this.validate() == false) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Заполнение созданного объекта\r\n\t\tthis.fillObject();\r\n\r\n\t\t// Поиск дубликатов. Если находим дубликат объекта - метод заканчивает работу.\r\n\t\tif (this.findDublicate(dublicateKey)) { \r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// Очистка полей ввода формы\r\n\t\tthis.cleanInputs();\r\n\t\t\r\n\t\t// Добавляем настроенный объект в базу данных.\r\n\t\tthis.addToDatabase();\r\n\r\n\r\n\t\t//Возвращаем созданный объект\r\n\t\treturn this.lastFilledObject;\r\n\t}\r\n\t\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод для заполнения объекта значениями с полей ввода в форме (input)\r\n\t * @param {number} id id объекта, который будет заполняется. (По умолчанию генерируется новый)\r\n \t * @return {object} Возвращает заполненный объект\r\n\t */\r\n\tfillObject(id){\r\n\t\t\r\n\t\tlet elements = this.currentForm.elements, // Список эллементов формы\r\n\t\t\tfillableObject, // Объект, который будет заполнен и возвращен методом.\r\n\t\t\taccumulateValues = \"\"; // Переменная, куда будут накапливаться значения в случае множественного выбора из <select>\r\n\r\n\t\t// Проверка и создание объекта нужного типа. \r\n\t\tswitch (this.getObjectType()) {\r\n\r\n\t\t\tcase \"book\":\r\n\t\t\t\tthis.lastFilledObject =  new Book;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase \"author\":\r\n\t\t\t\tthis.lastFilledObject =  new Author;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase \"genre\":\r\n\t\t\t\tthis.lastFilledObject =  new Genre;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t// // Очищаем свойство \"this.lastFilledObject\" от старых значений. \r\n\t\t// for (var prop in this.lastFilledObject) delete this.lastFilledObject[prop]; // ! РАЗОБРАТЬСЯ И УДАЛИТЬ ЗА НЕНАДОБНОСТЬЮ\r\n\r\n\t\t// Если мы передали \"id\" заполняемого объекта -- используем его в качестве id, если нет --генерируем новый id\r\n\t\tif (id) {\r\n\t\t\tthis.lastFilledObject[this.idName] = parseInt(id);\r\n\t\t}else{\r\n\t\t\t// Создаем и заполняем ID объекта\r\n\t\t\tthis.lastFilledObject[this.idName] = this.getID();\r\n\t\t}\r\n\t\t\r\n\t\t// Перебираем все поля ввода\r\n\t\tfor (let i = 0; i < elements.length; i++) {\r\n\r\n\t\t\t// Если элемент формы не имеет атрибута 'ignore'-- заполняем объект, если атрибут имеется -- игнорируем заполнения объекта\r\n\t\t\tif (elements[i].hasAttribute('ignore') == false) {\r\n\r\n\t\t\t\t// Если элемент типа \"select\" имеет атрибут \"multiple\" (Если присутствует множественный выбор)\r\n\t\t\t\tif (elements[i].type == \"select-multiple\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Перебираем в данном элементы все выбранные <option>\r\n\t\t\t\t\tfor (let k = 0; k < elements[i].selectedOptions.length; k++) {\r\n\r\n\t\t\t\t\t\t// и конкатенируем их в переменную \"accumulateValues\"\r\n\t\t\t\t\t\taccumulateValues += `${elements[i].selectedOptions[k].value}, \\n`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// После этого создаем свойство в объекте и записываем результат конкатенации в это свойство.\r\n\t\t\t\t\tthis.lastFilledObject[elements[i].getAttribute(\"id\")] = accumulateValues;\r\n\r\n\t\t\t\t// Иначе просто создаем свойство у объекта с таким же именем, как и значение атрибута \"id\" в input\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.lastFilledObject[elements[i].getAttribute(\"id\")] = elements[i].value;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t}\r\n\r\n\t\t// Клонируем объект, чтобы метод смог его вернуть как отдельный объект, а не ссылку;\r\n\t\tfillableObject = Object.assign({},this.lastFilledObject)\r\n\t\treturn fillableObject;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод очищает все поля текущей формы.\r\n\t * @todo Передлелать этот метод через цикл \"forEach\" или \"for in \"\r\n\t * @return Ничего не возвращает\r\n\t */\r\n\r\n\tcleanInputs(){\r\n\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\t\t\tlet boundId\t\t = this.currentForm.elements[i].dataset.boundId; // id элемента, в который выводить сообщении\r\n\t\t\tlet boundElement = document.querySelector(`#${boundId}`); // элемент, в который будет выводится сообщение\r\n\r\n\t\t\t// Если поле скрытое, или элемент формы — кнопка, то пропускаем и не очищаем эти элементы\r\n\t\t\tif (!(this.currentForm.elements[i].type == \"hidden\" || this.currentForm.elements[i].localName == \"button\" )) {\r\n\t\t\t\tthis.currentForm.elements[i].value = \"\";\r\n\t\t\t\tthis.currentForm.elements[i].classList.remove(\"inputs-invalid\", \"inputs-valid\");\r\n\t\t\t\tthis.currentForm.elements[i].classList.add(\"inputs-clean\");\r\n\t\t\t\tif (boundElement) {\r\n\t\t\t\t\tboundElement.style.display = \"none\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Очищаем последний выбранный объект;\r\n\t\tthis.selectedObject = null;\r\n\r\n\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Вариант1\r\n\t\t// for (const key in form.elements) {\r\n\t\t// \tif (form.elements.hasOwnProperty(key)) {\r\n\t\t// \t\tif (key.type != \"hidden\" || key.localName != \"button\") {\r\n\t\t// \t\t\tkey.value = \"\";\r\n\t\t// \t\t\tkey.className = \"inputs-clean\" \r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// }\r\n\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Вариант2\r\n\t\t// form.elements.forEach(element => {\r\n\t\t// \tif (element.type != \"hidden\" || element.localName != \"button\") {\r\n\t\t// \t\telement.value = \"\";\r\n\t\t// \t\telement.className = \"inputs-clean\" \r\n\t\t// \t}\r\n\t\t// });\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод устанавливает, объект какого типа заполнятся в форме. Для работы метода в форме должно быть поле <input type='hidden' id='objtype' value=''>, иначе метод выбросит исключение.\r\n\t * @return {string} Возвращает тип объекта, который заполняется в текущую форму\r\n\t */\r\n\tgetObjectType(){\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\t\t\tif (this.currentForm.elements[i].id == \"objtype\") {\r\n\t\t\t\treturn this.currentForm.elements[i].value\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow \"Не найдено поле ввода  <input type='hidden'> с указанием типа объекта, который будет передан в базу данный. Добавьте в вашу форму поле <input type='hidden' id='objtype' value=''>  В поле value='' укажите тип объекта, который будет добавлен в базу данных\"\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод проверяет дубликаты объектов. В случае нахождения дубликата выводит сообщение.\r\n\t * @param {string} dublicateKey название поля объекта, по которобу будет происходить поиск дубликатов. \r\n\t * @return {boolean} true, если дубликат найден, false — если не нашел.\r\n\t */\r\n\tfindDublicate(dublicateKey = this.idName){\r\n\r\n\t\tlet flag;\r\n\r\n\t\tif (!(this.dataArray)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// Тут производится сравнение по полю \"dublicateKey\". Если есть совпадение — считается, что найден дубликат и метод выводит сообщение.\r\n\t\tflag = this.dataArray.some(item =>item[dublicateKey] == this.lastFilledObject[dublicateKey]);\r\n\t\tif (flag) {\r\n\t\t\talert (\"такая запись уже есть\");\r\n\t\t}\r\n\t\treturn flag;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t//TODO Посмотреть метод validate\r\n\t/**\r\n\t * Метод проверяет форму на валидность (чтобы все необходимые поля были заполнены минимум 1 символом). \r\n\t * @return {boolean} \"true\", если все поля валидные. \"false\", если хотя-бы 1 поле не прошло проверку (тогда и форма считается не валидной)\r\n\t */\r\n\tvalidate() {\r\n\t\t\r\n\t\tlet counterOfInvalid = 0, // Счетчик полей, которые не прошли валидацию\r\n\t\t\telements = this.currentForm.elements; // Список элементов формы\r\n\t\t\t\r\n\t\tfor (let i = 0; i < elements.length; i++) {\r\n\r\n\t\t\tlet pattern \t \t= elements[i].dataset.pattern, // регуляр. выраж., по которому будет происходить проверка валидации.\r\n\t\t\t\tmessage \t \t= elements[i].dataset.message, // Сообщение, которое выводится в случае невалидности элемента\r\n\t\t\t\tboundId\t\t \t= elements[i].dataset.boundId, // id элемента, в который выводить сообщении\r\n\t\t\t\tboundElement \t= document.querySelector(`#${boundId}`), // элемент, в который будет выводится сообщение\r\n\t\t\t\tvalid \t\t \t= elements[i].value.search(pattern), // соответствие введеного значения -- паттерну\r\n\t\t\t\trequired\t\t= elements[i].required; // является ли поле обязательным для заполнения.\r\n\r\n\t\t\t// Валидацию будет проходить только тот элемент, у которого имеется свойство \"pattern\"\r\n\t\t\tif (required) {\r\n\r\n\t\t\t\tif (valid == -1) {\r\n\t\t\t\t\telements[i].classList.remove(\"inputs-valid\");\r\n\t\t\t\t\telements[i].classList.add(\"inputs-invalid\");\r\n\r\n\t\t\t\t\tif (boundElement) boundElement.innerHTML = message;\r\n\t\t\t\t\tif (boundElement) boundElement.style.display = \"block\";\r\n\t\t\t\t\r\n\t\t\t\t\tcounterOfInvalid++;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tboundElement.style.display = \"none\";\r\n\t\t\t\t\telements[i].classList.remove(\"inputs-invalid\");\r\n\t\t\t\t\telements[i].classList.add(\"inputs-valid\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Если счетчик невалидных элементов больше нуля — то и сама форма невалидная (вернуть \"false\")\r\n\t\tif (counterOfInvalid > 0) {\r\n\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод перезаписывает Local Storage переданным в параметре объектом.\r\n\t * @param {Array} newArray новый массив данных, которым нужно перезаписать Local Storage\r\n\t * @return {Array} Возращает новый, перезаписанный массив с Local Storage\r\n\t */\r\n\toverwriteLocalStorage(newArray){\r\n\r\n\t\tif (this.needAddToLocalStorege) {\r\n\t\t\tlocalStorage.setItem(this.localStorageKey, JSON.stringify(newArray));\r\n\t\t\treturn JSON.parse(localStorage.getItem(this.localStorageKey))\r\n\t\t}else{ // Случай, если мы не работаем с localStorage, но метод был вызван.\r\n\t\t\tconsole.warn(`Свойство ${this}.needAddToLocalStorege в значении ${this.needAddToLocalStorege}. Не удалось записать в Local Storage`); \r\n\t\t\treturn newArray;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод  добавляет переданный в параметре объект -- в Local Storage.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\taddToDatabase(object = this.lastFilledObject) {\r\n\r\n\t\t// Добавляем переданный объект \"object\" в масиив данных \"this.dataArray\"\r\n\t\tthis.dataArray.push(object);\r\n\r\n\t\t// Перезаписываем LocalStorage\r\n\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который удаляет объект из базы данных, который был передан в параметре.\r\n\t * @param {object} object Объект, который необходимо удалить. По умолчанию \"this.selectedObject\"\r\n\t * @return {Array} Возвращает актуальный массив данных. (или false, если нет объекта для удаления)\r\n\t */\r\n\tdeleteObject(object = this.selectedObject){\r\n\t\t\r\n\t\tif (object) {\r\n\t\t\tthis.dataArray.splice(this.findObject(object), 1);\r\n\t\t\t\r\n\t\t\t// Очищаем поля ввода.\r\n\t\t\tthis.cleanInputs();\r\n\t\t\tthis.selectedObject = null;\r\n\t\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t\t}else{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который изменяет объект в базе данных, который был передан в параметре.\r\n\t * @param {object} object Объект, который необходимо изменить. По умолчанию \"this.selectedObject\"\r\n\t * @return {Array} Возвращает актуальный массив данных. \r\n\t */\r\n\teditObject(object = this.selectedObject){\r\n\r\n\t\tlet copiedObject; // Переменная, чтобы склонировать объект \"this.lastFilledObject\"\r\n\t\t\r\n\t\tif (object && this.validate()) {\r\n\t\t\tthis.fillObject(object[this.idName])\r\n\r\n\t\t\t// Клонируем объект \"this.lastFilledObject\", для того, чтобы избавиться от копирования по ссылке.\r\n\t\t\tcopiedObject = Object.assign({},this.lastFilledObject)\r\n\r\n\t\t\tthis.dataArray[this.findObject(object)] = copiedObject; \r\n\t\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод находит индекс переданного в параметре объекта в текущем массиве данных (dataArray)\r\n\t * @param {object} object Объект, который нужно найти в массиве данных.\r\n\t * @return {number} Возвращает индекс объекта, который был передан в параметр.\r\n\t */\r\n\tfindObject(object){\r\n\r\n\t\treturn  this.dataArray.findIndex((item)=>{\r\n\t\t\t// Если совпадают значения \"id\" в переданном объекте и в массиве данных -- возращаем индекс. \r\n\t\t\treturn item[this.idName] == object[this.idName]\r\n\t\t})\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t *  Метод формирует уникальный идентификатор для нового объекта.\r\n\t * @return {number} Возращает новое значение \"id\", которого еще не было (самое большое текущее \"id\" +1)\r\n\t */\r\n\tgetID() {\r\n\r\n\t\tlet currentId = 0; // Текущий \"id\"\r\n\r\n\t\t// Если у нас присудствует массив с данными, то...\r\n\t\tif (this.dataArray) {\r\n\t\t\t// ...ищем самое большое значение \"id\"\r\n\t\t\tthis.dataArray.forEach(element => {\r\n\t\t\t\t\r\n\t\t\t\tif( parseInt(element[this.idName])  > currentId){\r\n\t\t\t\t\tcurrentId  = parseInt(element[this.idName])\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t// И возвращаем на 1 больше\r\n\t\t\treturn currentId + 1;\r\n\r\n\t\t// Если данных нет -- возвращаем просто 1 (предпологается что это запрос перед созданием массива с данными)\r\n\t\t}else{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * Метод формирует ключ для LocalStorage.\r\n\t * @param {string} postfix Постфикс (Часть, которая указывается в названии ключа после типа объекта для создания имени ключа LocalStorage (по умолчанию \"-library\"))\r\n\t * @return {string} Возвращает созданный ключ для LocalStorage.\r\n\t */\r\n\tgetLocalStorageKey(postfix = \"-library\"){\r\n\r\n\t\t//Находим в форме поле ввода с id == \"objtype\" (это поле типа  \"hidden\")\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\t\t\tif (this.currentForm.elements[i].id == \"objtype\") {\r\n\t\t\t\t\r\n\t\t\t\t// Возвращаем созданный  ключ\r\n\t\t\t\treturn this.currentForm.elements[i].value + postfix;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow \"Метод не смог найти поле с id == 'objtype' и value == '<название вашего объекта>'. Убедитесь что оно есть \"\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * Метод находит поле для ввода, у которого есть привязка к данным в базе данных и заполняет данными.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tcheckForm(){\r\n\r\n\t\tlet currentElement, \t // текущий элемент \"input\" формы. \r\n\t\t\trequired,\t\t\t // В переменную будет записано, нуждается ли поле в валидации.\r\n\t\t\tlocalStorageKeyBind, // Атрибут для привязки к имени массива объектов в локальном хранилище.\r\n\t\t\tobjectPropertyBind , // Атрибут для привязки к имени свойства объекта в локальном хранилище.\r\n\t\t\tarrayOfObjects,\t\t // Переменная, куда будут помещен массив из локального хранилища.\r\n\t\t\tinputLable;\t\t\t // Переменная с DOM-элементом \"lable\" для конкретного input.\t\r\n\r\n\t\t// Перебираем все элементы формы\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\r\n\t\t\tcurrentElement\t\t= this.currentForm.elements[i];\r\n\t\t\tlocalStorageKeyBind = currentElement.dataset.localStorageKeyBind;\r\n\t\t\tobjectPropertyBind \t= currentElement.dataset.objectPropertyBind;\r\n\t\t\tarrayOfObjects \t\t= JSON.parse(window.localStorage.getItem(localStorageKeyBind));\r\n\t\t\trequired\t\t\t= currentElement.required // Является ли поле обязательным для заполнения. \r\n\r\n\t\t\t// Добавляем к полю ввода подпись \"обязательно\".\r\n\t\t\tif (required) {\r\n\t\t\t\tinputLable = currentElement.labels[currentElement.labels.length - 1];\r\n\t\t\t\tinputLable.classList.add(\"input-required\");\r\n\t\t\t}\r\n\r\n\t\t\t// Если перебираемое поле для ввода содержит какую -либо из привязок -- тогда заполняем это поле объектами \r\n\t\t\tif (localStorageKeyBind && objectPropertyBind) {\r\n\t\t\t\tthis.fillInput(currentElement, arrayOfObjects);\r\n\r\n\t\t\t// Если пользователь привязал что-то одно (из двух необходимых атрибутов) -- выбрасываем исключение\r\n\t\t\t} else if(localStorageKeyBind){\r\n\t\t\t\tthrow \"Нет привязки к свойству объекта. Укажите в HTML элементе атрибут <objectPropertyBind> со значением свойства объекта, которое необходимо выводить.\"\r\n\t\t\t} else if(objectPropertyBind){\r\n\t\t\t\tthrow \"Нет привязки к Массиву объектов в LocalStorage. Укажите атрибут <localStorageKeyBind> со значением ключа, из которого необходимо получить данные для привязки.\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет элемент формы значениями с массива.\r\n\t * @param {object} element Елемент формы, который необходимо заполнить\r\n\t * @param {Array} arrayOfObjects Массив объектов, из которых нужно взять необходимое значение\r\n\t * @return {object} возвращает заполненный элемент\r\n\t */\r\n\tfillInput(element, arrayOfObjects){\r\n\r\n\t\tlet bindingKey = element.dataset.objectPropertyBind; // Свойство объекта, из которого необходимо взять значение и заполнить в элемент.\r\n\t\tlet elementType = element.tagName.toLowerCase(); // Тип  DOM-элемента\r\n\r\n\t\tif (arrayOfObjects) {\r\n\t\t\tswitch (elementType) {\r\n\r\n\t\t\t\t// пока метод реализован только чтобы заполнять <select> \r\n\t\t\t\tcase \"select\":\r\n\t\t\t\t\tfor (let i = 0; i < arrayOfObjects.length; i++) {\r\n\t\t\t\t\t\tlet optionElement = document.createElement(\"option\");\r\n\r\n\t\t\t\t\t\toptionElement.value = arrayOfObjects[i][bindingKey];\r\n\t\t\t\t\t\toptionElement.innerHTML = arrayOfObjects[i][bindingKey];\r\n\t\t\t\t\t\telement.appendChild(optionElement);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn element;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\treturn false;\r\n\t\t}\t\r\n\t}\r\n\r\n\t/**\r\n\t * Метод заполняет поля текущей формы (всей формы) значениями из объекта\r\n\t * @param {object} fillingObject Объект для заполнения формы. \r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tfillForm(fillingObject){\r\n\r\n\t\t// Перебираем все элементы формы\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\r\n\t\t\t// Если поле не скрытое, или элемент формы — не кнопка\r\n\t\t\tif (!(this.currentForm.elements[i].type == \"hidden\" || this.currentForm.elements[i].localName == \"button\" )) {\r\n\r\n\t\t\t\t// перебираем все свойства объекта \"fillingObject\"\r\n\t\t\t\tfor (const key in fillingObject) {\r\n\r\n\t\t\t\t\t// Если название свойства объекта соответсвует значению \"id\" в input-те\r\n\t\t\t\t\tif (key == this.currentForm.elements[i].id){\r\n\r\n\t\t\t\t\t\t// тогда заполняем поле значением со свойсва объекта.\r\n\t\t\t\t\t\tthis.currentForm.elements[i].value = fillingObject[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","module.exports = \"img/arrow-d.svg\";","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nclass Book{\r\n\t// Конструктор не применялся. Новый объект \"book\" заполняется с помощью цикла\r\n/* \tconstructor(id, name, author){\r\n\t\tthis.id = id;\r\n\t\tthis.name = name;\r\n\t\tthis.author = author;\r\n\r\n\t} */\r\n\r\n\t// constructor(array){\r\n\r\n\t// \tfor (let i = 0; i < array.length; i++) {\r\n\t\t\t\r\n\t// \t}\r\n\t// \t// array.forEach(element => {\r\n\t// \t// \telement.id = id;\r\n\t// \t// \telement.name = name;\r\n\t// \t// \telement.author = author;\r\n\t// \t// });\r\n\t// }\r\n\r\n}\r\n\r\nexport {Book};","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nexport class Genre{\r\n}\r\n","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nexport class Author{\r\n}\r\n"],"sourceRoot":""}