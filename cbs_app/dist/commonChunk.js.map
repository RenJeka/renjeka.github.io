{"version":3,"sources":["webpack:///./src/myHelperLib.js","webpack:///./src/generalClasses/table.class.js","webpack:///./src/generalClasses/form.class.js","webpack:///./src/objectsClasses/books.class.js","webpack:///./src/objectsClasses/genres.class.js","webpack:///./src/objectsClasses/authors.class.js"],"names":["$","selector","document","querySelector","changeClass","event","eventElement","targetElement","classOpened","addEventListener","i","length","classList","toggle","Table","currentTable","formObject","tableData","this","boundForm","currentForm","localStorageKey","arrayOfObservers","sortMark","sortDirection","otherRowSelectHandler","selectedRowIndex","selectedObject","observers","forEach","element","push","observerUpdate","onclick","bind","rowSelectHandler","addRows","rowIndex","getTableData","jsonObject","localStorage","getItem","JSON","parse","some","elem","sort","sortFunc1","undefined","dataInRow","numberOfRows","numberOfCells","arrayofRows","row","add","context","createElement","tBodies","appendChild","j","cell","addInfoInRow","rows","cells","indexOfRow","object","addInfoInCell","indexOfCell","key","hasOwnProperty","toLowerCase","getTableColumnHead","innerHTML","dataset","objectKeyBind","parseInt","deleteRow","input","objectProperty","filter","trim","includes","value","console","log","callbackHandler","eventObject","returnedValue","target","tagName","cleanTable","fillTable","parentElement","fillForm","setClassToElement","dir","notify","applyingСlass","className","a","b","remove","Form","idName","dataArray","getLocalStorageKey","needAddToLocalStorege","window","lastFilledObject","dublicateKey","validate","fillObject","findDublicate","cleanInputs","addToDatabase","id","elements","accumulateValues","getObjectType","Book","Author","Genre","getID","hasAttribute","type","k","selectedOptions","getAttribute","Object","assign","boundId","boundElement","localName","style","display","flag","item","alert","counterOfInvalid","pattern","message","valid","search","newArray","setItem","stringify","warn","overwriteLocalStorage","splice","findObject","copiedObject","findIndex","currentId","postfix","localStorageKeyBind","objectPropertyBind","arrayOfObjects","fillInput","bindingKey","elementType","optionElement","fillingObject"],"mappings":"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","file":"commonChunk.js","sourcesContent":["//  Моя вспомогательная библиотека. Тут находятся функции-помощники, чтобы не подключать JQuery.\r\n\r\n/**\r\n * Функция захвата DOM-элемента\r\n * @param {string} selector Селектор, по которому необходимо вернуть элемент\r\n * @return {object} Первый найденный элемент DOM-дерева.\r\n */\r\nfunction $(selector) {\r\n\treturn document.querySelector(selector);\r\n}\r\n\r\n/**\r\n * Функция, которая меняет (переключает) указанные классы (в ...rest -параметре) указанного DOM-элемента.\r\n * @description С помощью CSS классов невозможно изменить стили родительского элемента. Для решении этого применяется данная функция\r\n * @param {string} event Событие, по которому функция меняет класс.\r\n * @param {object} eventElement Элемент, на котором происходит событие.\r\n * @param {object} targetElement Целевой элемент, чьи классы должны изменится\r\n * @param {...any} classOpened Классы, которые должны поменятся (rest-параметр)\r\n * @return {void} Ничего не возвращает\r\n */\r\nfunction changeClass(event, eventElement, targetElement, ...classOpened){\r\n\teventElement.addEventListener(event, () => {\r\n\t\tfor (let i = 0; i < classOpened.length; i++) {\r\n\t\t\ttargetElement.classList.toggle(classOpened[i])\r\n\t\t}\r\n\t});\r\n}\r\n\r\nexport {$, changeClass};","import { $ } from \"../myHelperLib\";\r\n\r\n/**\r\n * Класс для создания объекта \"Таблица\"\r\n * Объект таблица является Наблюдаемым объектом (Observable) \r\n */\r\nexport class Table{\r\n\r\n\t/**\r\n\t * Конструктор. Создает объект -- таблица, которая подвязывается под 1 HTML-таблицу\r\n\t * @param {String} currentTable CSS -селектор для нахождения нужной (связанной таблицы)\r\n\t * @param {object} formObject Объект формы, созданный классом \"Form\"\r\n\t * @param {Array} tableData -- Массив объектов, которыми будет заполнятся таблица\r\n\t */\r\n\tconstructor(currentTable,formObject,tableData){\r\n\r\n\t\t/**\r\n\t\t * Текущая (связанная DOM-таблица).\r\n\t\t */\r\n\t\tthis.currentTable = $(currentTable);\r\n\r\n\t\t/**\r\n\t\t * Текущий объект формы(связанная форма).\r\n\t\t */\r\n\t\tthis.formObject = formObject;\r\n\r\n\t\t/**\r\n\t\t * Данные, которые заполняются в таблицу.\r\n\t\t */\r\n\t\tthis.tableData = tableData;\r\n\r\n\t\t/**\t\r\n\t\t * Привязанная форма под данную таблицу. Объект класса \"Form\".\r\n\t\t * @type {object}\r\n\t\t */\r\n\t\tthis.boundForm = formObject.currentForm;\r\n\r\n\t\t/**\r\n\t\t * Ключ от localStorage, где хранится массив данных с объектами, которые представлены в данной таблице\r\n\t\t * @type {string}\r\n\t\t */\r\n\t\tthis.localStorageKey = formObject.localStorageKey\r\n\r\n\t\t/**\t\r\n\t\t * Список подписчиков (паттерн Observer)\r\n\t\t * @type {Array}\r\n\t\t */\r\n\t\tthis.arrayOfObservers = [];\r\n\r\n\t\t/**\r\n\t\t * Свойство, которое содержит значение, по которому будут отсортированны данные в таблице\r\n\t\t * @type {string}\r\n\t\t */\r\n\t\tthis.sortMark;\r\n\r\n\t\t/**\r\n\t\t * Свойство, которое содержит направление сортировки данных в таблице. (прямое или обратное)\r\n\t\t * @type {boolean}\r\n\t\t */\r\n\t\tthis.sortDirection = true;\r\n\r\n\t\t/**\t\r\n\t\t * Свойство, которое содержит пользовательский обработчик событий (при клике на строку таблицы)\r\n\t\t * @type {function}\r\n\t\t */\r\n\t\tthis.otherRowSelectHandler;\r\n\r\n\t\t/**\r\n\t\t * Индекс строки, которая в данный момент выделена пользователем в таблице. (DOM-элемент)\r\n\t\t * @type {number}\r\n\t\t */\r\n\t\tthis.selectedRowIndex = null;\r\n\r\n\t\t/**\r\n\t\t * Объект, который привязан к текущей выделенной строку таблицы таблице\r\n\t\t * @type {object}\r\n\t\t */\r\n\t\tthis.selectedObject;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Метод добавляет подписчика в массив подписчиков (паттерн Observer)\r\n\t * @param {object} observers (rest-параметр) Подписчики (наблюдатели) за изменениями\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\taddObservers(...observers){\r\n\t\tobservers.forEach(element => {\r\n\t\t\tthis.arrayOfObservers.push(element);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Метод - уведомление подписчиков об изменениях (паттерн Observer). Этот метод создаваля для синхронизации параметра \"tableData\" и обработчика выбора строки \"rowSelectHandler\". Здесь объект класа Table ОДНОВРЕМЕННО и ИЗДАТЕЛЬ и ПОДПИСЧИК.\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\tnotify(){\r\n\t\tthis.arrayOfObservers.forEach(element => {\r\n\t\t\telement.observerUpdate({currentTable: this.currentTable, tableData: this.tableData, selectedObject: this.selectedObject})\r\n\t\t});\r\n\t\t// console.log(`selectedObject = `, this.selectedObject);\r\n\t}\r\n\t\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод update паттерна Observer\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\tobserverUpdate(){\r\n\t\tif (this.otherRowSelectHandler) {\r\n\t\t\tthis.currentTable.onclick = this.otherRowSelectHandler.bind(this);\r\n\t\t}else{\r\n\t\t\tthis.currentTable.onclick = this.rowSelectHandler.bind(this);\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет указанную таблицу, взяв данные с LocalStorage по ключу, либо указанным ранее массивом объектов.\r\n\t * @return {void} Возвращает массив с данными, которыми была заполнена таблица.\r\n\t */\r\n\tfillTable(sortMark,sortDirection) {\r\n\t\r\n\t\tif (sortMark) {\r\n\t\t\tthis.sortMark = sortMark;\r\n\t\t}\r\n\t\tif (sortDirection) {\r\n\t\t\tthis.sortDirection = sortDirection;\r\n\t\t}\r\n\t\t\r\n\t\t// Если у нас есть связанная таблица и готовый массив с данными для заполнения таблицы\r\n\t\tif (this.currentTable && this.tableData) {\r\n\t\t\t\r\n\t\t\t// Заполняем таблицу данными\r\n\t\t\tfor (let i = 0; i < this.tableData.length; i++) { // ? ForEach? \r\n\t\t\t\tthis.addRows(this.tableData[i]).rowIndex; \r\n\t\t\t}\r\n\r\n\t\t\t//Возвращаем массив, которым заполнили таблицу\r\n\t\t\treturn this.tableData;\r\n\r\n\t\t// Если у нас есть связанная таблица и ключ от localStorage\r\n\t\t}else if (this.currentTable && this.localStorageKey) {\r\n\r\n\t\t\t// Достаем данные из localStorage\r\n\t\t\tthis.tableData = this.getTableData();\r\n\r\n\t\t\t// Проверка на наличие данных в localStorage //TODO Проверить, правильная ли проверка\r\n\t\t\tif (this.tableData == false) {\r\n\r\n\t\t\t\t// Если в localStorage пустой массив -- возвращаем false\r\n\t\t\t\treturn false; \r\n\t\t\t}\r\n\r\n\t\t\t// Заполняем таблицу данными\r\n\t\t\tfor (let i = 0; i < this.tableData.length; i++) { // ? ForEach? \r\n\t\t\t\tthis.addRows(this.tableData[i]).rowIndex; \r\n\t\t\t}\r\n\r\n\t\t\t//Возвращаем массив, которым заполнили таблицу\r\n\t\t\treturn this.tableData;\r\n\r\n\t\t}else{\r\n\r\n\t\t\t// Если таблица не подвязана -- выброс исключения\r\n\t\t\tif (this.currentTable == false) {\r\n\t\t\t\tthrow `Не найдена связанная HTML-таблица. Пожалуйста добавьте HTML-таблицу в свойство ${this}.currentTable `;\r\n\r\n\t\t\t// Если у нас нет ни массива с данными, ни ключа localStorage -- выброс исключения\r\n\t\t\t}else if (this.localStorageKey == false && this.tableData == false) {\r\n\t\t\t\t\r\n\t\t\t\tthrow `Не найдены данные для заполнения HTML-таблицы. Пожалуйста добавте данные. Если у вас массив с данными -- добавьте этот массив в свойство  ${this}.tableData, если у вас данные в LocalStorage -- добавте ключ к данным в свойство ${this}.localStorageKey`;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод позволяет получить данные с LocalStorage для заполнения таблицы.  \r\n\t * @return {Object} Возвращает массив объектов, которым можно заполнить таблицу, или false, если не смог найти его в localStorage.\r\n\t */\r\n\tgetTableData() { \r\n\r\n\t\tlet jsonObject = localStorage.getItem(this.localStorageKey);\r\n\r\n\t\t// Если есть JSON-данные по переданному ключу — тогда возвращаем подготовленные данные, если JSON не найден — возвращаем false.\r\n\t\tif (jsonObject) {\r\n\r\n\t\t\t// Парсим данные из localStorage. Получаем массив с объектами\r\n\t\t\tjsonObject = JSON.parse(jsonObject);\r\n\r\n\t\t\t// Если поле для сортировки \"this.sortMark\" соответствует свойству в объекте\r\n\t\t\tif (jsonObject.some((elem)=>elem[this.sortMark])) {\r\n\r\n\t\t\t\t//Возвращаем отсортированный массив по заранее заданной функции\r\n\t\t\t\treturn jsonObject.sort(this.sortFunc1.bind(this)) \r\n\r\n\t\t\t// Если нет значения для сортировки \"this.sortMark\" — Возвращаем неотсортированный массив.\r\n\t\t\t}else if(this.sortMark == undefined){\r\n\t\t\t\treturn jsonObject;\r\n\r\n\t\t\t// Если значения для сортировки \"this.sortMark\" не верное — выбрасываем исключение. \r\n\t\t\t}else{\r\n\t\t\t\tthrow \"Значение, переданное для сортировки — не верное. Такого свойства у объекта нет.\"\r\n\t\t\t}\r\n\r\n\t\t}else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который добавляет ряды с ячейками в таблицу\r\n\t * @todo реализовать метод без замыкания (без внутреней функции)\r\n\t * @param {object} dataInRow Данные для 1 строки (1 объект)\t \r\n\t * @param {Number} numberOfRows Кол-во рядов (по умолчанию = 1)\r\n\t * @param {Number} numberOfCells Кол-во ячеек в ряде (По умолчанию высчитывается по кол-ву ячеек в заголовке (thead))\r\n\t * @return {arrayofRows} Возвращает созданный массив строк (либо 1 строку) с данными.\r\n\t */\r\n\taddRows(dataInRow, numberOfRows = 1, numberOfCells) {\r\n\t\t\r\n\t\tlet arrayofRows = [], // Массив будущих строк\r\n\t\t\trow; // Текущая строка\r\n\r\n\t\t// Эта функция собственно и добавляет ряд, ячейки и текст в таблицу. Принимает контекст, и возвращает массив с созданными строками\r\n\t\tfunction add(context) {\r\n\t\t\t\r\n\t\t\t// Цикл добавляеи по 1-й строке то кол-во, которое мы укажем (numberOfRows)\r\n\t\t\tfor (let i = 0; i < numberOfRows; i++) {\r\n\r\n\t\t\t\trow = document.createElement(\"tr\")\r\n\t\t\t\tcontext.currentTable.tBodies[0].appendChild(row)\r\n\r\n\t\t\t\t// Цикл добавляет по 1-й ячейке то кол-во, которое мы укажем (numberOfCells)\r\n\t\t\t\tfor (let j = 0; j < numberOfCells; j++) {\r\n\r\n\t\t\t\t\tlet cell = document.createElement(\"td\")\r\n\t\t\t\t\trow.appendChild(cell)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tarrayofRows.push(row);\r\n\t\t\t\t\r\n\t\t\t\tif (dataInRow) {\r\n\t\t\t\t\tcontext.addInfoInRow(row.rowIndex, dataInRow);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn arrayofRows;\r\n\t\t}\r\n\r\n\t\t// Проверка на наличие аргумента \"numberOfCells\", если его нет— за количестко ячеек высчитывается из количества ячеек первого ряда (из \"thead\");\r\n\t\tif (numberOfCells == undefined) {\r\n\t\t\tnumberOfCells = this.currentTable.rows[0].cells.length;\r\n\t\t}\r\n\r\n\t\t// Этот способ будет использоваться чаще всего и возвращать 1 созданный ряд с данными.\r\n\t\tif (numberOfRows == 1) {\r\n\r\n\t\t\tarrayofRows = add(this) // ? return add(this)[0] -- попробовать вернуть это\r\n\t\t\treturn arrayofRows[0];\r\n\t\t}\r\n\t\treturn add(this);\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * метод, который заполняет ряд таблицы. Использует метод \"addInfoInCell\", который заполняет каждую ячейку\r\n\t * @param {Number} indexOfRow Индекс ряда в таблице, который будет заполнятся данными \r\n\t * @param {Object} object Объект с данными для заполнения ряда. \r\n\t * @return {void} Ничего не возвращает\r\n\t*/\r\n\taddInfoInRow(indexOfRow, object) {\r\n\r\n\t\tfor (let i = 0; i < this.currentTable.rows[indexOfRow].cells.length; i++) {\r\n\t\t\tthis.addInfoInCell(object, indexOfRow, i)\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет одну указанную ячейку в указанном ряде таблицы. Нужен для работы метода addInfoInRow\r\n\t * @param {Object} object Объект с данными для заполнения ячейки.\r\n\t * @param {Number} indexOfRow Индекс ряда, в котором находится нужная для заполнения ячейка\r\n\t * @param {Number} indexOfCell Индекс ячейки, которая будет заполнятся.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\taddInfoInCell(object, indexOfRow, indexOfCell) {\r\n\r\n\t\tfor (const key in object) {\r\n\t\t\tif (object.hasOwnProperty(key)) {\r\n\r\n\t\t\t\t// Если ключ объекта равняется тому, что вернул метот \"getTableColumnHead\" — значение из объекта заполняется в заранее заданную ячейку\r\n\t\t\t\tif (key.toLowerCase() === this.getTableColumnHead(indexOfCell).toLowerCase()){\r\n\r\n\t\t\t\t\tthis.currentTable.rows[indexOfRow].cells[indexOfCell].innerHTML = object[key];\r\n\r\n\t\t\t\t\t// Возвращаем заполненную ячейку\r\n\t\t\t\t\treturn this.currentTable.rows[indexOfRow].cells[indexOfCell]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод вычисляет, какой заголовок находиться над указанной ячейкой (Заголовок колонки). Нужен для работы метода \"addInfoInCell\"\r\n\t * @param {Number} indexOfCell Индекс ячейки, у которой необходимо узнать заголовок.\r\n\t * @return {String} Возвращает название заголовка над ячейкой.\r\n\t * @see addInfoInCell\r\n\t */\r\n\tgetTableColumnHead(indexOfCell) {\r\n\r\n\t\t// Получаем значение из атрибута \"data-object-key-bind\" в заголовочной ячейки\r\n\t\tlet nameOfTableHead = this.currentTable.rows[0].cells[indexOfCell].dataset.objectKeyBind;\r\n\t\treturn nameOfTableHead;\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод полностью очищает конкретный ряд либо таблицу целиком\r\n\t * @param {number} indexOfRow Индекс строки, которую нужно удалить. Если параметр отсутствует --таблица очистится полностью.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tcleanTable(indexOfRow){\r\n\r\n\t\tindexOfRow = parseInt(indexOfRow);\r\n\r\n\t\tif (indexOfRow) {\r\n\t\t\t// Проверка, правильно ли введен индекс строки\r\n\t\t\tif (indexOfRow <= this.currentTable.rows.length -1  && indexOfRow >= 0) {\r\n\r\n\t\t\t\t// Удаляем строку по индексу \"indexOfRow\"\r\n\t\t\t\tthis.currentTable.deleteRow(indexOfRow)\r\n\t\t\t}else{\r\n\t\t\t\tthrow \"Невозможно удалить строку. Такой строки не существует. Проверьте правильность передаваемого в параметр значения.\"\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// Запускаем цикл на иттераций равную кол-во строк в таблице. Каждый раз удаляем последнюю строку.\r\n\t\t\twhile (this.currentTable.rows.length > 1) {\r\n\t\t\t\tthis.currentTable.deleteRow(this.currentTable.rows.length - 1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод поиска. Фильтрует массив по значению input.value, и возвращает его.\r\n\t * @param {object} input Элемент, в который вводится фильтрирующее значение.\r\n\t * @param {string} objectProperty Имя свойства объекта, по которому будет происходить фильтрация.\r\n\t * @return {Array} Возвращает отфильтнованный массив либо false, если массив не удалось найти.\r\n\t */\r\n\tsearch(input, objectProperty){\r\n\t\tlet tempVariable;\r\n\t\tthis.tableData = this.getTableData();\r\n\r\n\t\tif(this.tableData){\r\n\r\n\t\t\ttempVariable = this.tableData.filter(element => {\r\n\r\n\t\t\t\t// Переводим значение свойства объекта в нижний регистр \r\n\t\t\t\tlet tempProperty = element[objectProperty].trim().toLowerCase();\r\n\t\t\t\t// Если \"tempProperty\" содержит то, что мы ввели в \"input\" -- значит это искомое значение.\r\n\t\t\t\treturn tempProperty.includes(input.value.trim().toLowerCase());\r\n\t\t\t});\r\n\t\t\treturn tempVariable;\r\n\t\t\t  \r\n\t\t}else{\r\n\t\t\tconsole.log (\"Не удалось найти массив с данными\")\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод запускает обработчик события по клику на строку. Можно подвесить свой обработчик (callbackHandler)\r\n\t * @param {Function} callbackHandler Функция, которая ставится в качестве обработчика на нажатие по таблице. (По умолчанию this.rowSelectHandler)\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\ttableClickHandler(callbackHandler){\r\n\r\n\t\tthis.otherRowSelectHandler = callbackHandler;\r\n\r\n\t\tif (this.otherRowSelectHandler) {\r\n\t\t\tthis.currentTable.onclick = this.otherRowSelectHandler.bind(this);\r\n\t\t}else{\r\n\t\t\tthis.currentTable.onclick = this.rowSelectHandler.bind(this);\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод обрабатывает клик по строке. Его задача отсортировать таблицу, если клик был по заголовку, или вернуть строку, если клик был по \"не заголовочной\" строке.\r\n\t * @todo Ножна ли тут переменная \"returnedValue\" ?\r\n\t * @param {object} eventObject Объект события, который передается при клике.\r\n\t * @return {object} Возвращщает массив с данными после сортировки, либо объект, на который кликнул пользователь.\r\n\t */\r\n\trowSelectHandler(eventObject){\r\n\r\n\t\tlet returnedValue; // Значение, которое возвращает этот метод.\r\n\r\n\t\t\r\n\t\tthis.sortMark = eventObject.target.dataset.objectKeyBind; // Записываем название свойства для сортировки\r\n\t\t\t\r\n\t\t// Проверка, если есть атрибут \"objectKeyBind\" у HTML элемента -- сортируем таблицу\r\n\t\tif (this.sortMark && eventObject.target.tagName == \"TH\") {\r\n\r\n\t\t\tthis.sortDirection = !this.sortDirection;\r\n\t\t\t\r\n\t\t\t// Сортируем текущие данные. (Учитывая потерю контекста)\r\n\t\t\tthis.tableData.sort(this.sortFunc1.bind(this));\r\n\r\n\t\t\t// Очищаем всю таблицу\r\n\t\t\tthis.cleanTable();\r\n\r\n\t\t\t// Заполняе новыми значениями (с учетом сортировки)\r\n\t\t\treturnedValue = this.fillTable();\r\n\t\t\tthis.tableData = returnedValue;\r\n\r\n\t\t\tthis.selectedRowIndex = null;\r\n\t\t\tthis.selectedObject = null;\r\n\r\n\t\t// Если пользователь кликнул по строке с данными -- находим индекс строки и возвращаем объект с массива объектов (по этому индексу)\r\n\t\t}else if(eventObject.target.tagName == \"TD\"){\r\n\r\n\t\t\tthis.selectedRowIndex = eventObject.target.parentElement.rowIndex; // Записываем индекс выделенной строки\r\n\r\n\t\t\treturnedValue = this.tableData[this.selectedRowIndex -1];\r\n\t\t\tthis.selectedObject = returnedValue;\r\n\t\t\tthis.formObject.fillForm(this.selectedObject)\r\n\t\t\tthis.setClassToElement(this.currentTable.rows[this.selectedRowIndex], \"row-selected\")\r\n\t\t\t\r\n\t\t\tconsole.log(`selectedObject =  `, this.selectedObject);\r\n\t\t\tconsole.dir(`this.selectedRowIndex = ${this.selectedRowIndex} `);\r\n\t\t}\r\n\r\n\t\t// по окончанию метода запускаем метод паттерна \"observer\" -- notify() чтобы обновить все данные.\r\n\t\tthis.notify();\r\n\r\n\t\treturn returnedValue;\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который проходится по таблице и применяет стиль к 1 конкретному ряду (строке).\r\n\t * @todo Как установить правильно класс элементу\r\n\t * @param {object} row Ряд к которому необходимо применить клас\r\n\t * @param {string} applyingСlass css клас, который нужно применить к ряду.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tsetClassToElement(row, applyingСlass){\r\n\t\tfor (let i = 0; i < this.currentTable.rows.length ; i++) {\r\n\t\t\tthis.currentTable.rows[i].className = \"\";\r\n\t\t\tif (this.currentTable.rows[i] == row) {\r\n\t\t\t\tthis.currentTable.rows[i].className = applyingСlass;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который передается в сортировку массива. Сортирует значения по возрастанию, либо по убыванию в зависимости от значения \"this.sortDirection\".\r\n\t * @param {object} a Первый параметр для сравнения со вторым\r\n\t * @param {object} b Второй параметр для сравнения с первым.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tsortFunc1(a, b) { \r\n\t\t\r\n\t\tif (this.sortDirection) {\r\n\t\t\tif (a[this.sortMark] >  b[this.sortMark]) return 1; // если первое значение больше второго\r\n\t\t\tif (a[this.sortMark] == b[this.sortMark]) return 0; // если равны\r\n\t\t\tif (a[this.sortMark] <  b[this.sortMark]) return -1; // если первое значение меньше второго\r\n\t\t}else{\r\n\t\t\tif (a[this.sortMark] <  b[this.sortMark]) return 1; \r\n\t\t\tif (a[this.sortMark] == b[this.sortMark]) return 0;\r\n\t\t\tif (a[this.sortMark] >  b[this.sortMark]) return -1;\r\n\t\t}\t\r\n\t}\r\n\t\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод обнуляет выделенную строку в таблице и в форме\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tnullifySelection(){\r\n\r\n\t\tif (this.selectedRowIndex != null && this.currentTable.rows[this.selectedRowIndex]) {\r\n\r\n\t\t\tthis.currentTable.rows[this.selectedRowIndex].classList.remove(\"row-selected\");\r\n\t\t}\r\n\r\n\t\tthis.formObject.selectedObject = null;\r\n\t\tthis.selectedRowIndex = null;\r\n\t\tthis.selectedObject = null;\r\n\t}\r\n}","import { Book} from '../objectsClasses/books.class';\r\nimport { Genre } from '../objectsClasses/genres.class';\r\nimport { Author } from '../objectsClasses/authors.class';\r\n\r\n/**\r\n * Класс для создания объекта \"Форма\"\r\n */\r\nexport class Form{\r\n\r\n\t/**\r\n\t * Конструктор класса \"Form\". Создает объект -- Форма, который подвязывается под под 1 HTML -форму.\r\n\t * @param {object} currentForm  Текущая <HTML>-форма, которая привязывается к данному объекту\r\n\t * @param {String} idName название ID для идентификации каждого объекта\r\n\t * @param {Array} dataArray (не обязательный) Массив данных, (набор объектов, что заполняется в форме). По умолчанию данные записываются в  localStorage.\r\n\t */\r\n\tconstructor(currentForm, idName, dataArray){\r\n\r\n\t\t/**\r\n\t\t * Текущая <HTML>-форма, которая привязывается к данному объекту\r\n\t\t */\r\n\t\tthis.currentForm = currentForm;\r\n\r\n\t\t/**\r\n\t\t * название ID для идентификации каждого объекта\r\n\t\t */\r\n\t\tthis.idName = idName;\r\n\r\n\t\t/**\r\n\t\t * (не обязательный) Массив данных, (набор объектов, что заполняется в форме). По умолчанию данные записываются в  localStorage.\r\n\t\t */\r\n\t\tthis.dataArray = [];\r\n\r\n\t\t/**\t\r\n\t\t * Ключ от localStorage, где хранится массив данных с объектами, которые которые обрабатывает данная форма.\r\n\t\t */\r\n\t\tthis.localStorageKey = this.getLocalStorageKey(\"-library\");\r\n\r\n\t\t/**\t\r\n\t\t * Нужно ли добавлять данные в LocalStorege (true -нужно, false -не нужно)\r\n\t\t */\r\n\t\tthis.needAddToLocalStorege = true;\r\n\r\n\t\t// TODO Как сделать так, чтобы объекты 2 разных классов знали друг о друге сразу, через конструктор. (И нужно ли вообще это?)\r\n\t\t// this.tableObject = tableObject;\r\n\t\t// this.tableObject;\r\n\r\n\t\tif (dataArray) {\r\n\t\t\tthis.dataArray = dataArray;\r\n\t\t\tthis.needAddToLocalStorege = false;\r\n\r\n\t\t}else if(window.localStorage.getItem(this.localStorageKey)){\r\n\t\t\tthis.dataArray = JSON.parse(window.localStorage.getItem(this.localStorageKey));\r\n\t\t}\r\n\t\t/**\t\r\n\t\t * Последний (текущий) объект, который заполнялся.\r\n\t\t */\r\n\t\tthis.lastFilledObject = {}; \r\n\r\n\t\t/**\t\r\n\t\t * Объект, который в текущий момент выбран в таблице.\r\n\t\t */\r\n\t\tthis.selectedObject;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * @param {object} Принимает объект с 4 свойсвами (свойства объекта класса Table) : currentTable - текущая таблица, tableData - текущий массив, которым заполнена таблица, selectedObject - текущий выбранный объект в таблице\r\n\t * Метод подписчика, обновляет данные \"this.selectedObject\"\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tobserverUpdate({currentTable, tableData, selectedObject}){\r\n\t\tthis.selectedObject = selectedObject\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Обработчик событий при нажатии на кнопку добавления объекта в базу данных. Берет с формы данные и записывает в базу данных.\r\n\t * @param {string} dublicateKey Ключ, по которому будет происходить поиск дубликатов (по умолчанию дубликатом считается объект с таким-же ID)\r\n\t * @return {object} Возвращает заполненный объект;\r\n\t */\r\n\taddButtonHandler(dublicateKey = this.idName) {\r\n\r\n\t\t// Проверка валидации. Если валидация вернула \"false\" — то закончить выполнение текущего метода\r\n\t\tif (this.validate() == false) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Заполнение созданного объекта\r\n\t\tthis.fillObject();\r\n\r\n\t\t// Поиск дубликатов. Если находим дубликат объекта - метод заканчивает работу.\r\n\t\tif (this.findDublicate(dublicateKey)) { \r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// Очистка полей ввода формы\r\n\t\tthis.cleanInputs();\r\n\t\t\r\n\t\t// Добавляем настроенный объект в базу данных.\r\n\t\tthis.addToDatabase();\r\n\r\n\t\t//Возвращаем созданный объект\r\n\t\treturn this.lastFilledObject;\r\n\t}\r\n\t\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод для заполнения объекта значениями с полей ввода в форме (input)\r\n\t * @param {number} id id объекта, который будет заполняется. (По умолчанию генерируется новый)\r\n \t * @return {object} Возвращает заполненный объект\r\n\t */\r\n\tfillObject(id){\r\n\t\t\r\n\t\tlet elements = this.currentForm.elements, // Список эллементов формы\r\n\t\t\tfillableObject, // Объект, который будет заполнен и возвращен методом.\r\n\t\t\taccumulateValues = \"\"; // Переменная, куда будут накапливаться значения в случае множественного выбора из <select>\r\n\r\n\t\t// Проверка и создание объекта нужного типа. \r\n\t\tswitch (this.getObjectType()) {\r\n\r\n\t\t\tcase \"book\":\r\n\t\t\t\tthis.lastFilledObject =  new Book;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase \"author\":\r\n\t\t\t\tthis.lastFilledObject =  new Author;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase \"genre\":\r\n\t\t\t\tthis.lastFilledObject =  new Genre;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t// // Очищаем свойство \"this.lastFilledObject\" от старых значений. \r\n\t\t// for (var prop in this.lastFilledObject) delete this.lastFilledObject[prop]; // ! РАЗОБРАТЬСЯ И УДАЛИТЬ ЗА НЕНАДОБНОСТЬЮ\r\n\r\n\t\t// Если мы передали \"id\" заполняемого объекта -- используем его в качестве id, если нет --генерируем новый id\r\n\t\tif (id) {\r\n\t\t\tthis.lastFilledObject[this.idName] = parseInt(id);\r\n\t\t}else{\r\n\t\t\t// Создаем и заполняем ID объекта\r\n\t\t\tthis.lastFilledObject[this.idName] = this.getID();\r\n\t\t}\r\n\t\t\r\n\t\t// Перебираем все поля ввода\r\n\t\tfor (let i = 0; i < elements.length; i++) {\r\n\t\t\t// console.dir(elements[i]);\r\n\t\t\t// Если элемент формы не имеет атрибута 'ignore'-- заполняем объект, если атрибут имеется -- игнорируем заполнения объекта\r\n\t\t\tif (elements[i].hasAttribute('ignore') == false) {\r\n\r\n\t\t\t\t// Если элемент типа \"select\" имеет атрибут \"multiple\" (Если присутствует множественный выбор)\r\n\t\t\t\tif (elements[i].type == \"select-multiple\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Перебираем в данном элементы все выбранные <option>\r\n\t\t\t\t\tfor (let k = 0; k < elements[i].selectedOptions.length; k++) {\r\n\r\n\t\t\t\t\t\t// и конкатенируем их в переменную \"accumulateValues\"\r\n\t\t\t\t\t\taccumulateValues += `${elements[i].selectedOptions[k].value}, \\n`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// После этого создаем свойство в объекте и записываем результат конкатенации в это свойство.\r\n\t\t\t\t\tthis.lastFilledObject[elements[i].getAttribute(\"id\")] = accumulateValues;\r\n\r\n\t\t\t\t// Иначе просто создаем свойство у объекта с таким же именем, как и значение атрибута \"id\" в input\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.lastFilledObject[elements[i].getAttribute(\"id\")] = elements[i].value;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t}\r\n\r\n\t\t// Клонируем объект, чтобы метод смог его вернуть как отдельный объект, а не ссылку;\r\n\t\tfillableObject = Object.assign({},this.lastFilledObject)\r\n\t\treturn fillableObject;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод очищает все поля текущей формы.\r\n\t * @todo Передлелать этот метод через цикл \"forEach\" или \"for in \"\r\n\t * @return Ничего не возвращает\r\n\t */\r\n\r\n\tcleanInputs(){\r\n\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\t\t\tlet boundId\t\t = this.currentForm.elements[i].dataset.boundId; // id элемента, в который выводить сообщении\r\n\t\t\tlet boundElement = document.querySelector(`#${boundId}`); // элемент, в который будет выводится сообщение\r\n\r\n\t\t\t// Если поле скрытое, или элемент формы — кнопка, то пропускаем и не очищаем эти элементы\r\n\t\t\tif (!(this.currentForm.elements[i].type == \"hidden\" || this.currentForm.elements[i].localName == \"button\" )) {\r\n\t\t\t\tthis.currentForm.elements[i].value = \"\";\r\n\t\t\t\tthis.currentForm.elements[i].classList.remove(\"inputs-invalid\", \"inputs-valid\");\r\n\t\t\t\tthis.currentForm.elements[i].classList.add(\"inputs-clean\");\r\n\t\t\t\tif (boundElement) {\r\n\t\t\t\t\tboundElement.style.display = \"none\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t// Очищаем последний выбранный объект;\r\n\t\tthis.selectedObject = null;\r\n\r\n\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Вариант1\r\n\t\t// for (const key in form.elements) {\r\n\t\t// \tif (form.elements.hasOwnProperty(key)) {\r\n\t\t// \t\tif (key.type != \"hidden\" || key.localName != \"button\") {\r\n\t\t// \t\t\tkey.value = \"\";\r\n\t\t// \t\t\tkey.className = \"inputs-clean\" \r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// }\r\n\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Вариант2\r\n\t\t// form.elements.forEach(element => {\r\n\t\t// \tif (element.type != \"hidden\" || element.localName != \"button\") {\r\n\t\t// \t\telement.value = \"\";\r\n\t\t// \t\telement.className = \"inputs-clean\" \r\n\t\t// \t}\r\n\t\t// });\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод устанавливает, объект какого типа заполнятся в форме. Для работы метода в форме должно быть поле <input type='hidden' id='objtype' value=''>, иначе метод выбросит исключение.\r\n\t * @return {string} Возвращает тип объекта, который заполняется в текущую форму\r\n\t */\r\n\tgetObjectType(){\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\t\t\tif (this.currentForm.elements[i].id == \"objtype\") {\r\n\t\t\t\treturn this.currentForm.elements[i].value\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow \"Не найдено поле ввода  <input type='hidden'> с указанием типа объекта, который будет передан в базу данный. Добавьте в вашу форму поле <input type='hidden' id='objtype' value=''>  В поле value='' укажите тип объекта, который будет добавлен в базу данных\"\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод проверяет дубликаты объектов. В случае нахождения дубликата выводит сообщение.\r\n\t * @param {string} dublicateKey название поля объекта, по которобу будет происходить поиск дубликатов. \r\n\t * @return {boolean} true, если дубликат найден, false — если не нашел.\r\n\t */\r\n\tfindDublicate(dublicateKey = this.idName){\r\n\r\n\t\tlet flag;\r\n\r\n\t\tif (!(this.dataArray)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// Тут производится сравнение по полю \"dublicateKey\". Если есть совпадение — считается, что найден дубликат и метод выводит сообщение.\r\n\t\tflag = this.dataArray.some(item =>item[dublicateKey] == this.lastFilledObject[dublicateKey]);\r\n\t\tif (flag) {\r\n\t\t\talert (\"такая запись уже есть\");\r\n\t\t}\r\n\t\treturn flag;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t//TODO Посмотреть метод validate\r\n\t/**\r\n\t * Метод проверяет форму на валидность (чтобы все необходимые поля были заполнены минимум 1 символом). \r\n\t * @return {boolean} \"true\", если все поля валидные. \"false\", если хотя-бы 1 поле не прошло проверку (тогда и форма считается не валидной)\r\n\t */\r\n\tvalidate() {\r\n\t\t\r\n\t\tlet counterOfInvalid = 0, // Счетчик полей, которые не прошли валидацию\r\n\t\t\telements = this.currentForm.elements; // Список элементов формы\r\n\r\n\t\tfor (let i = 0; i < elements.length; i++) {\r\n\r\n\t\t\tlet pattern \t = elements[i].dataset.pattern, // регуляр. выраж., по которому будет происходить проверка валидации.\r\n\t\t\t\tmessage \t = elements[i].dataset.message, // Сообщение, которое выводится в случае невалидности элемента\r\n\t\t\t\tboundId\t\t = elements[i].dataset.boundId, // id элемента, в который выводить сообщении\r\n\t\t\t\tboundElement = document.querySelector(`#${boundId}`), // элемент, в который будет выводится сообщение\r\n\t\t\t\tvalid \t\t = elements[i].value.search(pattern); // соответствие введеного значения -- паттерну\r\n\r\n\t\t\t// Валидацию будет проходить только тот элемент, у которого имеется свойство \"pattern\"\r\n\t\t\tif (pattern) {\r\n\r\n\t\t\t\tif (valid == -1) {\r\n\t\t\t\t\telements[i].classList.remove(\"inputs-valid\");\r\n\t\t\t\t\telements[i].classList.add(\"inputs-invalid\");\r\n\r\n\t\t\t\t\tif (boundElement) boundElement.innerHTML = message;\r\n\t\t\t\t\tif (boundElement) boundElement.style.display = \"block\";\r\n\t\t\t\t\r\n\t\t\t\t\tcounterOfInvalid++;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tboundElement.style.display = \"none\";\r\n\t\t\t\t\telements[i].classList.remove(\"inputs-invalid\");\r\n\t\t\t\t\telements[i].classList.add(\"inputs-valid\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Если счетчик невалидных элементов больше нуля — то и сама форма невалидная (вернуть \"false\")\r\n\t\tif (counterOfInvalid > 0) {\r\n\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод перезаписывает Local Storage переданным в параметре объектом.\r\n\t * @param {Array} newArray новый массив данных, которым нужно перезаписать Local Storage\r\n\t * @return {Array} Возращает новый, перезаписанный массив с Local Storage\r\n\t */\r\n\toverwriteLocalStorage(newArray){\r\n\r\n\t\tif (this.needAddToLocalStorege) {\r\n\t\t\tlocalStorage.setItem(this.localStorageKey, JSON.stringify(newArray));\r\n\t\t\treturn JSON.parse(localStorage.getItem(this.localStorageKey))\r\n\t\t}else{ // Случай, если мы не работаем с localStorage, но метод был вызван.\r\n\t\t\tconsole.warn(`Свойство ${this}.needAddToLocalStorege в значении ${this.needAddToLocalStorege}. Не удалось записать в Local Storage`); \r\n\t\t\treturn newArray;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод  добавляет переданный в параметре объект -- в Local Storage.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\taddToDatabase(object = this.lastFilledObject) {\r\n\r\n\t\t// Добавляем переданный объект \"object\" в масиив данных \"this.dataArray\"\r\n\t\tthis.dataArray.push(object);\r\n\r\n\t\t// Перезаписываем LocalStorage\r\n\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который удаляет объект из базы данных, который был передан в параметре.\r\n\t * @param {object} object Объект, который необходимо удалить. По умолчанию \"this.selectedObject\"\r\n\t * @return {Array} Возвращает актуальный массив данных. (или false, если нет объекта для удаления)\r\n\t */\r\n\tdeleteObject(object = this.selectedObject){\r\n\t\t\r\n\t\tif (object) {\r\n\t\t\tthis.dataArray.splice(this.findObject(object), 1);\r\n\t\t\t\r\n\t\t\t// Очищаем поля ввода.\r\n\t\t\tthis.cleanInputs();\r\n\t\t\tthis.selectedObject = null;\r\n\t\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t\t}else{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который изменяет объект в базе данных, который был передан в параметре.\r\n\t * @param {object} object Объект, который необходимо изменить. По умолчанию \"this.selectedObject\"\r\n\t * @return {Array} Возвращает актуальный массив данных. \r\n\t */\r\n\teditObject(object = this.selectedObject){\r\n\r\n\t\tlet copiedObject; // Переменная, чтобы склонировать объект \"this.lastFilledObject\"\r\n\t\t\r\n\t\tif (object && this.validate()) {\r\n\t\t\tthis.fillObject(object[this.idName])\r\n\r\n\t\t\t// Клонируем объект \"this.lastFilledObject\", для того, чтобы избавиться от копирования по ссылке.\r\n\t\t\tcopiedObject = Object.assign({},this.lastFilledObject)\r\n\r\n\t\t\tthis.dataArray[this.findObject(object)] = copiedObject; \r\n\t\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод находит индекс переданного в параметре объекта в текущем массиве данных (dataArray)\r\n\t * @param {object} object Объект, который нужно найти в массиве данных.\r\n\t * @return {number} Возвращает индекс объекта, который был передан в параметр.\r\n\t */\r\n\tfindObject(object){\r\n\r\n\t\treturn  this.dataArray.findIndex((item)=>{\r\n\t\t\t// Если совпадают значения \"id\" в переданном объекте и в массиве данных -- возращаем индекс. \r\n\t\t\treturn item[this.idName] == object[this.idName]\r\n\t\t})\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t *  Метод формирует уникальный идентификатор для нового объекта.\r\n\t * @return {number} Возращает новое значение \"id\", которого еще не было (самое большое текущее \"id\" +1)\r\n\t */\r\n\tgetID() {\r\n\r\n\t\tlet currentId = 0; // Текущий \"id\"\r\n\r\n\t\t// Если у нас присудствует массив с данными, то...\r\n\t\tif (this.dataArray) {\r\n\t\t\t// ...ищем самое большое значение \"id\"\r\n\t\t\tthis.dataArray.forEach(element => {\r\n\t\t\t\t\r\n\t\t\t\tif( parseInt(element[this.idName])  > currentId){\r\n\t\t\t\t\tcurrentId  = parseInt(element[this.idName])\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t// И возвращаем на 1 больше\r\n\t\t\treturn currentId + 1;\r\n\r\n\t\t// Если данных нет -- возвращаем просто 1 (предпологается что это запрос перед созданием массива с данными)\r\n\t\t}else{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * Метод формирует ключ для LocalStorage.\r\n\t * @param {string} postfix Постфикс (Часть, которая указывается в названии ключа после типа объекта для создания имени ключа LocalStorage (по умолчанию \"-library\"))\r\n\t * @return {string} Возвращает созданный ключ для LocalStorage.\r\n\t */\r\n\tgetLocalStorageKey(postfix = \"-library\"){\r\n\r\n\t\t//Находим в форме поле ввода с id == \"objtype\" (это поле типа  \"hidden\")\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\t\t\tif (this.currentForm.elements[i].id == \"objtype\") {\r\n\t\t\t\t\r\n\t\t\t\t// Возвращаем созданный  ключ\r\n\t\t\t\treturn this.currentForm.elements[i].value + postfix;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow \"Метод не смог найти поле с id == 'objtype' и value == '<название вашего объекта>'. Убедитесь что оно есть \"\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * Метод находит поле для ввода, у которого есть привязка к данным в базе данных и заполняет данными.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tcheckForm(){\r\n\r\n\t\tlet localStorageKeyBind,\r\n\t\t\tobjectPropertyBind ,\r\n\t\t\tarrayOfObjects;\r\n\r\n\t\t// Перебираем все элементы формы\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\r\n\t\t\tlocalStorageKeyBind = this.currentForm.elements[i].dataset.localStorageKeyBind;\r\n\t\t\tobjectPropertyBind = this.currentForm.elements[i].dataset.objectPropertyBind;\r\n\t\t\tarrayOfObjects = JSON.parse(window.localStorage.getItem(localStorageKeyBind));\r\n\r\n\t\t\t// Если перебираемое поле для ввода содержит какую -либо из привязок -- тогда заполняем это поле объектами \r\n\t\t\tif (localStorageKeyBind && objectPropertyBind) {\r\n\t\t\t\tthis.fillInput(this.currentForm.elements[i], arrayOfObjects);\r\n\r\n\t\t\t// Если пользователь привязал что-то одно (из двух необходимых атрибутов) -- выбрасываем исключение\r\n\t\t\t} else if(localStorageKeyBind){\r\n\t\t\t\tthrow \"Нет привязки к свойству объекта. Укажите в HTML элементе атрибут <objectPropertyBind> со значением свойства объекта, которое необходимо выводить.\"\r\n\t\t\t} else if(objectPropertyBind){\r\n\t\t\t\tthrow \"Нет привязки к Массиву объектов в LocalStorage. Укажите атрибут <localStorageKeyBind> со значением ключа, из которого необходимо получить данные для привязки.\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет элемент формы значениями с массива.\r\n\t * @param {object} element Елемент формы, который необходимо заполнить\r\n\t * @param {Array} arrayOfObjects Массив объектов, из которых нужно взять необходимое значение\r\n\t * @return {object} возвращает заполненный элемент\r\n\t */\r\n\tfillInput(element, arrayOfObjects){\r\n\r\n\t\tlet bindingKey = element.dataset.objectPropertyBind; // Свойство объекта, из которого необходимо взять значение и заполнить в элемент.\r\n\t\tlet elementType = element.tagName.toLowerCase(); // Тип  DOM-элемента\r\n\r\n\t\tif (arrayOfObjects) {\r\n\t\t\tswitch (elementType) {\r\n\r\n\t\t\t\t// пока метод реализован только чтобы заполнять <select> \r\n\t\t\t\tcase \"select\":\r\n\t\t\t\t\tfor (let i = 0; i < arrayOfObjects.length; i++) {\r\n\t\t\t\t\t\tlet optionElement = document.createElement(\"option\");\r\n\r\n\t\t\t\t\t\toptionElement.value = arrayOfObjects[i][bindingKey];\r\n\t\t\t\t\t\toptionElement.innerHTML = arrayOfObjects[i][bindingKey];\r\n\t\t\t\t\t\telement.appendChild(optionElement);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn element;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\treturn false;\r\n\t\t}\t\r\n\t}\r\n\r\n\t/**\r\n\t * Метод заполняет поля текущей формы (всей формы) значениями из объекта\r\n\t * @param {object} fillingObject Объект для заполнения формы. \r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tfillForm(fillingObject){\r\n\r\n\t\t// Перебираем все элементы формы\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\r\n\t\t\t// Если поле не скрытое, или элемент формы — не кнопка\r\n\t\t\tif (!(this.currentForm.elements[i].type == \"hidden\" || this.currentForm.elements[i].localName == \"button\" )) {\r\n\r\n\t\t\t\t// перебираем все свойства объекта \"fillingObject\"\r\n\t\t\t\tfor (const key in fillingObject) {\r\n\r\n\t\t\t\t\t// Если название свойства объекта соответсвует значению \"id\" в input-те\r\n\t\t\t\t\tif (key == this.currentForm.elements[i].id){\r\n\r\n\t\t\t\t\t\t// тогда заполняем поле значением со свойсва объекта.\r\n\t\t\t\t\t\tthis.currentForm.elements[i].value = fillingObject[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nclass Book{\r\n\t// Конструктор не применялся. Новый объект \"book\" заполняется с помощью цикла\r\n/* \tconstructor(id, name, author){\r\n\t\tthis.id = id;\r\n\t\tthis.name = name;\r\n\t\tthis.author = author;\r\n\r\n\t} */\r\n\r\n\t// constructor(array){\r\n\r\n\t// \tfor (let i = 0; i < array.length; i++) {\r\n\t\t\t\r\n\t// \t}\r\n\t// \t// array.forEach(element => {\r\n\t// \t// \telement.id = id;\r\n\t// \t// \telement.name = name;\r\n\t// \t// \telement.author = author;\r\n\t// \t// });\r\n\t// }\r\n\r\n}\r\n\r\nexport {Book};","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nexport class Genre{\r\n}\r\n","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nexport class Author{\r\n}\r\n"],"sourceRoot":""}