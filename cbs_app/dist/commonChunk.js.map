{"version":3,"sources":["webpack:///./src/myHelperLib.js","webpack:///./src/generalClasses/table.class.js","webpack:///./src/generalClasses/form.class.js","webpack:///./src/objectsClasses/books.class.js","webpack:///./src/objectsClasses/genres.class.js","webpack:///./src/objectsClasses/authors.class.js"],"names":["$","selector","document","querySelector","Table","currentTable","formObject","tableData","this","boundForm","currentForm","localStorageKey","arrayOfObservers","sortMark","sortDirection","otherRowSelectHandler","selectedObject","observers","forEach","element","push","observerUpdate","onclick","bind","rowSelectHandler","i","length","addRows","rowIndex","getTableData","jsonObject","localStorage","getItem","JSON","parse","some","elem","sort","sortFunc1","undefined","dataInRow","numberOfRows","numberOfCells","arrayofRows","row","add","context","createElement","tBodies","appendChild","j","cell","addInfoInRow","rows","cells","indexOfRow","object","addInfoInCell","indexOfCell","key","hasOwnProperty","toLowerCase","getTableColumnHead","innerHTML","dataset","objectKeyBind","parseInt","deleteRow","input","objectProperty","filter","trim","includes","value","console","log","callbackHandler","eventObject","returnedValue","target","tagName","cleanTable","fillTable","parentElement","fillForm","setClassToElement","notify","applyingСlass","className","a","b","Form","idName","dataArray","getLocalStorageKey","needAddToLocalStorege","window","lastFilledObject","dublicateKey","validate","getObjectType","Book","Author","Genre","fillObject","findDublicate","cleanInputs","addToDatabase","id","elements","accumulateValues","prop","getID","hasAttribute","type","k","selectedOptions","getAttribute","Object","assign","localName","flag","item","alert","counterOfInvalid","pattern","message","boundId","boundElement","valid","search","newArray","setItem","stringify","warn","overwriteLocalStorage","splice","findObject","copiedObject","findIndex","currentId","postfix","localStorageKeyBind","objectPropertyBind","arrayOfObjects","fillInput","bindingKey","elementType","optionElement","fillingObject"],"mappings":"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","file":"commonChunk.js","sourcesContent":["//  Моя вспомогательная библиотека. Тут находятся функции-помощники, чтобы не подключать JQuery.\r\n\r\nfunction $(selector) {\r\n\treturn document.querySelector(selector);\r\n}\r\n\r\nexport {$};","import { $ } from \"../myHelperLib\";\r\n\r\n/**\r\n * Класс для создания объекта \"Таблица\"\r\n * Объект таблица является Наблюдаемым объектом (Observable) \r\n */\r\nexport class Table{\r\n\r\n\t/**\r\n\t * Конструктор. Создает объект -- таблица, которая подвязывается под 1 HTML-таблицу\r\n\t * @param {String} currentTable CSS -селектор для нахождения нужной (связанной таблицы)\r\n\t * @param {object} formObject Объект формы, созданный классом \"Form\"\r\n\t * @param {Array} tableData -- Массив объектов, которыми будет заполнятся таблица\r\n\t */\r\n\tconstructor(currentTable,formObject,tableData){\r\n\t\tthis.currentTable = $(currentTable);\r\n\t\tthis.formObject = formObject;\r\n\t\tthis.tableData = tableData;\r\n\r\n\t\t/**\t\r\n\t\t * Привязанная форма под данную таблицу. Объект класса \"Form\".\r\n\t\t */\r\n\t\tthis.boundForm = formObject.currentForm;\r\n\r\n\t\t/**\r\n\t\t * Ключ от localStorage, где хранится массив данных с объектами, которые представлены в данной таблице\r\n\t\t */\r\n\t\tthis.localStorageKey = formObject.localStorageKey\r\n\r\n\t\t/**\t\r\n\t\t * Список подписчиков (паттерн Observer)\r\n\t\t */\r\n\t\tthis.arrayOfObservers = [];\r\n\r\n\t\t/**\r\n\t\t * Свойство, которое содержит значение, по которому будут отсортированны данные в таблице\r\n\t\t */\r\n\t\tthis.sortMark;\r\n\r\n\t\t/**\r\n\t\t * Свойство, которое содержит направление сортировки данных в таблице. (прямое или обратное)\r\n\t\t */\r\n\t\tthis.sortDirection = true;\r\n\r\n\t\t/**\t\r\n\t\t * Свойство, которое содержит пользовательский обработчик событий (при клике на строку таблицы)\r\n\t\t */\r\n\t\tthis.otherRowSelectHandler;\r\n\r\n\t\t/**\r\n\t\t * Текущий объект, который в данный момент выделен пользователем в таблице\r\n\t\t */\r\n\t\tthis.selectedObject;\r\n\t}\r\n\r\n\t/**\r\n\t * Метод добавляет подписчика в массив подписчиков (паттерн Observer)\r\n\t * @param {object} observers (rest-параметр) Подписчики (наблюдатели) за изменениями\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\taddObservers(...observers){\r\n\t\tobservers.forEach(element => {\r\n\t\t\tthis.arrayOfObservers.push(element);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Метод - уведомление подписчиков об изменениях (паттерн Observer). Этот метод создаваля для синхронизации параметра \"tableData\" и обработчика выбора строки \"rowSelectHandler\". Здесь объект класа Table ОДНОВРЕМЕННО и ИЗДАТЕЛЬ и ПОДПИСЧИК.\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\tnotify(){\r\n\t\tthis.arrayOfObservers.forEach(element => {\r\n\t\t\telement.observerUpdate({currentTable: this.currentTable, tableData: this.tableData, selectedObject: this.selectedObject})\r\n\t\t});\r\n\t\t// console.log(`selectedObject = `, this.selectedObject);\r\n\t}\r\n\t\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод update паттерна Observer\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\tobserverUpdate(){\r\n\t\tif (this.otherRowSelectHandler) {\r\n\t\t\tthis.currentTable.onclick = this.otherRowSelectHandler.bind(this);\r\n\t\t}else{\r\n\t\t\tthis.currentTable.onclick = this.rowSelectHandler.bind(this);\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет указанную таблицу, взяв данные с LocalStorage по ключу, либо указанным ранее массивом объектов.\r\n\t * @return {void} Возвращает массив с данными, которыми была заполнена таблица.\r\n\t */\r\n\tfillTable(sortMark,sortDirection) {\r\n\t\r\n\t\tif (sortMark) {\r\n\t\t\tthis.sortMark = sortMark;\r\n\t\t}\r\n\t\tif (sortDirection) {\r\n\t\t\tthis.sortDirection = sortDirection;\r\n\t\t}\r\n\t\t\r\n\t\t// Если у нас есть связанная таблица и готовый массив с данными для заполнения таблицы\r\n\t\tif (this.currentTable && this.tableData) {\r\n\t\t\t\r\n\t\t\t// Заполняем таблицу данными\r\n\t\t\tfor (let i = 0; i < this.tableData.length; i++) { // ? ForEach? \r\n\t\t\t\tthis.addRows(this.tableData[i]).rowIndex; \r\n\t\t\t}\r\n\r\n\t\t\t//Возвращаем массив, которым заполнили таблицу\r\n\t\t\treturn this.tableData;\r\n\r\n\t\t// Если у нас есть связанная таблица и ключ от localStorage\r\n\t\t}else if (this.currentTable && this.localStorageKey) {\r\n\r\n\t\t\t// Достаем данные из localStorage\r\n\t\t\tthis.tableData = this.getTableData();\r\n\r\n\t\t\t// Проверка на наличие данных в localStorage //TODO Проверить, правильная ли проверка\r\n\t\t\tif (this.tableData == false) {\r\n\r\n\t\t\t\t// Если в localStorage пустой массив -- возвращаем false\r\n\t\t\t\treturn false; \r\n\t\t\t}\r\n\r\n\t\t\t// Заполняем таблицу данными\r\n\t\t\tfor (let i = 0; i < this.tableData.length; i++) { // ? ForEach? \r\n\t\t\t\tthis.addRows(this.tableData[i]).rowIndex; \r\n\t\t\t}\r\n\r\n\t\t\t//Возвращаем массив, которым заполнили таблицу\r\n\t\t\treturn this.tableData;\r\n\r\n\t\t}else{\r\n\r\n\t\t\t// Если таблица не подвязана -- выброс исключения\r\n\t\t\tif (this.currentTable == false) {\r\n\t\t\t\tthrow `Не найдена связанная HTML-таблица. Пожалуйста добавьте HTML-таблицу в свойство ${this}.currentTable `;\r\n\r\n\t\t\t// Если у нас нет ни массива с данными, ни ключа localStorage -- выброс исключения\r\n\t\t\t}else if (this.localStorageKey == false && this.tableData == false) {\r\n\t\t\t\t\r\n\t\t\t\tthrow `Не найдены данные для заполнения HTML-таблицы. Пожалуйста добавте данные. Если у вас массив с данными -- добавьте этот массив в свойство  ${this}.tableData, если у вас данные в LocalStorage -- добавте ключ к данным в свойство ${this}.localStorageKey`;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод позволяет получить данные с LocalStorage для заполнения таблицы.  \r\n\t * @return {Object} Возвращает массив объектов, которым можно заполнить таблицу, или false, если не смог найти его в localStorage.\r\n\t */\r\n\tgetTableData() { \r\n\r\n\t\tlet jsonObject = localStorage.getItem(this.localStorageKey);\r\n\r\n\t\t// Если есть JSON-данные по переданному ключу — тогда возвращаем подготовленные данные, если JSON не найден — возвращаем false.\r\n\t\tif (jsonObject) {\r\n\r\n\t\t\t// Парсим данные из localStorage. Получаем массив с объектами\r\n\t\t\tjsonObject = JSON.parse(jsonObject);\r\n\r\n\t\t\t// Если поле для сортировки \"this.sortMark\" соответствует свойству в объекте\r\n\t\t\tif (jsonObject.some((elem)=>elem[this.sortMark])) {\r\n\r\n\t\t\t\t//Возвращаем отсортированный массив по заранее заданной функции\r\n\t\t\t\treturn jsonObject.sort(this.sortFunc1.bind(this)) \r\n\r\n\t\t\t// Если нет значения для сортировки \"this.sortMark\" — Возвращаем неотсортированный массив.\r\n\t\t\t}else if(this.sortMark == undefined){\r\n\t\t\t\treturn jsonObject;\r\n\r\n\t\t\t// Если значения для сортировки \"this.sortMark\" не верное — выбрасываем исключение. \r\n\t\t\t}else{\r\n\t\t\t\tthrow \"Значение, переданное для сортировки — не верное. Такого свойства у объекта нет.\"\r\n\t\t\t}\r\n\r\n\t\t}else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который добавляет ряды с ячейками в таблицу\r\n\t * @todo реализовать метод без замыкания (без внутреней функции)\r\n\t * @param {object} dataInRow Данные для 1 строки (1 объект)\t \r\n\t * @param {Number} numberOfRows Кол-во рядов (по умолчанию = 1)\r\n\t * @param {Number} numberOfCells Кол-во ячеек в ряде (По умолчанию высчитывается по кол-ву ячеек в заголовке (thead))\r\n\t * @return {arrayofRows} Возвращает созданный массив строк (либо 1 строку) с данными.\r\n\t */\r\n\taddRows(dataInRow, numberOfRows = 1, numberOfCells) {\r\n\t\t\r\n\t\tlet arrayofRows = [], // Массив будущих строк\r\n\t\t\trow; // Текущая строка\r\n\r\n\t\t// Эта функция собственно и добавляет ряд, ячейки и текст в таблицу. Принимает контекст, и возвращает массив с созданными строками\r\n\t\tfunction add(context) {\r\n\t\t\t\r\n\t\t\t// Цикл добавляеи по 1-й строке то кол-во, которое мы укажем (numberOfRows)\r\n\t\t\tfor (let i = 0; i < numberOfRows; i++) {\r\n\r\n\t\t\t\trow = document.createElement(\"tr\")\r\n\t\t\t\tcontext.currentTable.tBodies[0].appendChild(row)\r\n\r\n\t\t\t\t// Цикл добавляет по 1-й ячейке то кол-во, которое мы укажем (numberOfCells)\r\n\t\t\t\tfor (let j = 0; j < numberOfCells; j++) {\r\n\r\n\t\t\t\t\tlet cell = document.createElement(\"td\")\r\n\t\t\t\t\trow.appendChild(cell)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tarrayofRows.push(row);\r\n\t\t\t\t\r\n\t\t\t\tif (dataInRow) {\r\n\t\t\t\t\tcontext.addInfoInRow(row.rowIndex, dataInRow);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn arrayofRows;\r\n\t\t}\r\n\r\n\t\t// Проверка на наличие аргумента \"numberOfCells\", если его нет— за количестко ячеек высчитывается из количества ячеек первого ряда (из \"thead\");\r\n\t\tif (numberOfCells == undefined) {\r\n\t\t\tnumberOfCells = this.currentTable.rows[0].cells.length;\r\n\t\t}\r\n\r\n\t\t// Этот способ будет использоваться чаще всего и возвращать 1 созданный ряд с данными.\r\n\t\tif (numberOfRows == 1) {\r\n\r\n\t\t\tarrayofRows = add(this) // ? return add(this)[0] -- попробовать вернуть это\r\n\t\t\treturn arrayofRows[0];\r\n\t\t}\r\n\t\treturn add(this);\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * метод, который заполняет ряд таблицы. Использует метод \"addInfoInCell\", который заполняет каждую ячейку\r\n\t * @param {Number} indexOfRow Индекс ряда в таблице, который будет заполнятся данными \r\n\t * @param {Object} object Объект с данными для заполнения ряда. \r\n\t * @return {void} Ничего не возвращает\r\n\t*/\r\n\taddInfoInRow(indexOfRow, object) {\r\n\r\n\t\tfor (let i = 0; i < this.currentTable.rows[indexOfRow].cells.length; i++) {\r\n\t\t\tthis.addInfoInCell(object, indexOfRow, i)\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет одну указанную ячейку в указанном ряде таблицы. Нужен для работы метода addInfoInRow\r\n\t * @param {Object} object Объект с данными для заполнения ячейки.\r\n\t * @param {Number} indexOfRow Индекс ряда, в котором находится нужная для заполнения ячейка\r\n\t * @param {Number} indexOfCell Индекс ячейки, которая будет заполнятся.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\taddInfoInCell(object, indexOfRow, indexOfCell) {\r\n\r\n\t\tfor (const key in object) {\r\n\t\t\tif (object.hasOwnProperty(key)) {\r\n\r\n\t\t\t\t// Если ключ объекта равняется тому, что вернул метот \"getTableColumnHead\" — значение из объекта заполняется в заранее заданную ячейку\r\n\t\t\t\tif (key.toLowerCase() === this.getTableColumnHead(indexOfCell).toLowerCase()){\r\n\r\n\t\t\t\t\tthis.currentTable.rows[indexOfRow].cells[indexOfCell].innerHTML = object[key];\r\n\r\n\t\t\t\t\t// Возвращаем заполненную ячейку\r\n\t\t\t\t\treturn this.currentTable.rows[indexOfRow].cells[indexOfCell]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод вычисляет, какой заголовок находиться над указанной ячейкой (Заголовок колонки). Нужен для работы метода \"addInfoInCell\"\r\n\t * @param {Number} indexOfCell Индекс ячейки, у которой необходимо узнать заголовок.\r\n\t * @return {String} Возвращает название заголовка над ячейкой.\r\n\t * @see addInfoInCell\r\n\t */\r\n\tgetTableColumnHead(indexOfCell) {\r\n\r\n\t\t// Получаем значение из атрибута \"data-object-key-bind\" в заголовочной ячейки\r\n\t\tlet nameOfTableHead = this.currentTable.rows[0].cells[indexOfCell].dataset.objectKeyBind;\r\n\t\treturn nameOfTableHead;\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод полностью очищает конкретный ряд либо таблицу целиком\r\n\t * @param {number} indexOfRow Индекс строки, которую нужно удалить. Если параметр отсутствует --таблица очистится полностью.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tcleanTable(indexOfRow){\r\n\r\n\t\tindexOfRow = parseInt(indexOfRow);\r\n\r\n\t\tif (indexOfRow) {\r\n\t\t\t// Проверка, правильно ли введен индекс строки\r\n\t\t\tif (indexOfRow <= this.currentTable.rows.length -1  && indexOfRow >= 0) {\r\n\r\n\t\t\t\t// Удаляем строку по индексу \"indexOfRow\"\r\n\t\t\t\tthis.currentTable.deleteRow(indexOfRow)\r\n\t\t\t}else{\r\n\t\t\t\tthrow \"Невозможно удалить строку. Такой строки не существует. Проверьте правильность передаваемого в параметр значения.\"\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// Запускаем цикл на иттераций равную кол-во строк в таблице. Каждый раз удаляем последнюю строку.\r\n\t\t\twhile (this.currentTable.rows.length > 1) {\r\n\t\t\t\tthis.currentTable.deleteRow(this.currentTable.rows.length - 1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод поиска. Фильтрует массив по значению input.value, и возвращает его.\r\n\t * @param {object} input Элемент, в который вводится фильтрирующее значение.\r\n\t * @param {string} objectProperty свойство (название свойства) объекта, по которому будет происходить фильтрация.\r\n\t * @return {Array} Возвращает отфильтнованный массив либо false, если массив не удалось найти.\r\n\t */\r\n\tsearch(input, objectProperty){\r\n\t\tlet tempVariable;\r\n\t\tthis.tableData = this.getTableData();\r\n\r\n\t\tif(this.tableData){\r\n\r\n\t\t\ttempVariable = this.tableData.filter(element => {\r\n\r\n\t\t\t\t// Переводим значение свойства объекта в нижний регистр \r\n\t\t\t\tlet tempProperty = element[objectProperty].trim().toLowerCase();\r\n\t\t\t\t// Если \"tempProperty\" содержит то, что мы ввели в \"input\" -- значит это искомое значение.\r\n\t\t\t\treturn tempProperty.includes(input.value.trim().toLowerCase());\r\n\t\t\t});\r\n\t\t\treturn tempVariable;\r\n\t\t\t  \r\n\t\t}else{\r\n\t\t\tconsole.log (\"Не удалось найти массив с данными\")\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод запускает обработчик события по клику на строку. Можно подвесить свой обработчик (callbackHandler)\r\n\t * @param {Function} callbackHandler Функция, которая ставится в качестве обработчика на нажатие по таблице. (По умолчанию this.rowSelectHandler)\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\ttableClickHandler(callbackHandler){\r\n\r\n\t\tthis.otherRowSelectHandler = callbackHandler;\r\n\r\n\t\tif (this.otherRowSelectHandler) {\r\n\t\t\tthis.currentTable.onclick = this.otherRowSelectHandler.bind(this);\r\n\t\t}else{\r\n\t\t\tthis.currentTable.onclick = this.rowSelectHandler.bind(this);\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод обрабатывает клик по строке. Его задача отсортировать таблицу, если клик был по заголовку, или вернуть строку, если клик был по \"не заголовочной\" строке.\r\n\t * @todo Ножна ли тут переменная \"returnedValue\" ?\r\n\t * @param {object} eventObject Объект события, который передается при клике.\r\n\t * @return {object} Возвращщает массив с данными после сортировки, либо объект, на который кликнул пользователь.\r\n\t */\r\n\trowSelectHandler(eventObject){\r\n\r\n\t\tlet returnedValue; // Значение, которое возвращает этот метод.\r\n\t\t\r\n\t\tthis.sortMark = eventObject.target.dataset.objectKeyBind;\r\n\t\t\t\r\n\t\t// Проверка, если есть атрибут \"objectKeyBind\" у HTML элемента -- сортируем таблицу\r\n\t\tif (this.sortMark && eventObject.target.tagName == \"TH\") {\r\n\r\n\t\t\tthis.sortDirection = !this.sortDirection;\r\n\t\t\t\r\n\t\t\t// Сортируем текущие данные. (Учитывая потерю контекста)\r\n\t\t\tthis.tableData.sort(this.sortFunc1.bind(this));\r\n\r\n\t\t\t// Очищаем всю таблицу\r\n\t\t\tthis.cleanTable();\r\n\r\n\t\t\t// Заполняе новыми значениями (с учетом сортировки)\r\n\t\t\treturnedValue = this.fillTable();\r\n\t\t\tthis.tableData = returnedValue;\r\n\t\t\tthis.selectedObject = null;\r\n\r\n\t\t// Если пользователь кликнул по строке с данными -- находим индекс строки и возвращаем объект с массива объектов (по этому индексу)\r\n\t\t}else if(eventObject.target.tagName == \"TD\"){\r\n\t\t\treturnedValue = this.tableData[eventObject.target.parentElement.rowIndex -1];\r\n\t\t\tthis.selectedObject = returnedValue;\r\n\t\t\tthis.formObject.fillForm(this.selectedObject)\r\n\r\n\t\t\tthis.setClassToElement(eventObject.target.parentElement, \"row-selected\")\r\n\t\t}\r\n\r\n\t\t// по окончанию метода запускаем метод паттерна \"observer\" -- notify() чтобы обновить все данные.\r\n\t\tthis.notify();\r\n\r\n\t\treturn returnedValue;\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который проходится по таблице и применяет стиль к 1 конкретному ряду (строке).\r\n\t * @todo Как установить правильно класс элементу\r\n\t * @param {object} row Ряд к которому необходимо применить клас\r\n\t * @param {string} applyingСlass css клас, который нужно применить к ряду.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tsetClassToElement(row, applyingСlass){\r\n\t\tfor (let i = 0; i<this.currentTable.rows.length ; i++) {\r\n\t\t\tthis.currentTable.rows[i].className = \"\";\r\n\t\t\tif (this.currentTable.rows[i] == row) {\r\n\t\t\t\tthis.currentTable.rows[i].className = applyingСlass;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который передается в сортировку массива. Сортирует значения по возрастанию, либо по убыванию в зависимости от значения \"this.sortDirection\".\r\n\t * @param {object} a Первый параметр для сравнения со вторым\r\n\t * @param {object} b Второй параметр для сравнения с первым.\r\n\t */\r\n\tsortFunc1(a, b) { \r\n\r\n\t\tif (this.sortDirection) {\r\n\t\t\tif (a[this.sortMark] >  b[this.sortMark]) return 1; // если первое значение больше второго\r\n\t\t\tif (a[this.sortMark] == b[this.sortMark]) return 0; // если равны\r\n\t\t\tif (a[this.sortMark] <  b[this.sortMark]) return -1; // если первое значение меньше второго\r\n\t\t}else{\r\n\t\t\tif (a[this.sortMark] <  b[this.sortMark]) return 1; \r\n\t\t\tif (a[this.sortMark] == b[this.sortMark]) return 0;\r\n\t\t\tif (a[this.sortMark] >  b[this.sortMark]) return -1;\r\n\t\t}\t\r\n\t}\r\n}","import { Book} from '../objectsClasses/books.class';\r\nimport { Genre } from '../objectsClasses/genres.class';\r\nimport { Author } from '../objectsClasses/authors.class';\r\n\r\n/**\r\n * Класс для создания объекта \"Форма\"\r\n */\r\nexport class Form{\r\n\r\n\t/**\r\n\t * Конструктор класса \"Form\". Создает объект -- Форма, который подвязывается под под 1 HTML -форму.\r\n\t * @param {object} currentForm  Текущая <HTML>-форма, которая привязывается к данному объекту\r\n\t * @param {String} idName название ID для идентификации каждого объекта\r\n\t * @param {Array} dataArray (не обязательный) Массив данных, (набор объектов, что заполняется в форме). По умолчанию данные записываются в  localStorage.\r\n\t */\r\n\tconstructor(currentForm, idName, dataArray){\r\n\t\tthis.currentForm = currentForm;\r\n\t\tthis.idName = idName;\r\n\t\tthis.dataArray = [];\r\n\r\n\t\t/**\t\r\n\t\t * Ключ от localStorage, где хранится массив данных с объектами, которые которые обрабатывает данная форма.\r\n\t\t */\r\n\t\tthis.localStorageKey = this.getLocalStorageKey(\"-library\");\r\n\r\n\t\t/**\t\r\n\t\t * Нужно ли добавлять данные в LocalStorege (true -нужно, false -не нужно)\r\n\t\t */\r\n\t\tthis.needAddToLocalStorege = true;\r\n\r\n\t\t// TODO Как сделать так, чтобы объекты 2 разных классов знали друг о друге сразу, через конструктор. (И нужно ли вообще это?)\r\n\t\t// this.tableObject = tableObject;\r\n\t\t// this.tableObject;\r\n\r\n\t\tif (dataArray) {\r\n\t\t\tthis.dataArray = dataArray;\r\n\t\t\tthis.needAddToLocalStorege = false;\r\n\r\n\t\t}else if(window.localStorage.getItem(this.localStorageKey)){\r\n\t\t\tthis.dataArray = JSON.parse(window.localStorage.getItem(this.localStorageKey));\r\n\t\t}\r\n\t\t/**\t\r\n\t\t * Последний (текущий) объект, который заполнялся.\r\n\t\t */\r\n\t\tthis.lastFilledObject = {}; \r\n\r\n\t\t/**\t\r\n\t\t * Объект, который в текущий момент выбран в таблице.\r\n\t\t */\r\n\t\tthis.selectedObject;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * @param {object} Принимает объект с 4 свойсвами (свойства объекта класса Table) : currentTable - текущая таблица, tableData - текущий массив, которым заполнена таблица, selectedObject - текущий выбранный объект в таблице\r\n\t * Метод подписчика, обновляет данные \"this.selectedObject\"\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tobserverUpdate({currentTable, tableData, selectedObject}){\r\n\t\tthis.selectedObject = selectedObject\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Обработчик событий при нажатии на кнопку добавления объекта в базу данных. Берет с формы данные и записывает в базу данных.\r\n\t * @param {string} dublicateKey Ключ, по которому будет происходить поиск дубликатов (по умолчанию дубликатом считается объект с таким-же ID)\r\n\t * @return {object} Возвращает заполненный объект;\r\n\t */\r\n\taddButtonHandler(dublicateKey = this.idName) {\r\n\r\n\t\t// Проверка валидации. Если валидация вернула \"false\" — то закончить выполнение текущего метода\r\n\t\tif (this.validate() == false) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Проверка и создание объекта нужного типа. \r\n\t\tswitch (this.getObjectType()) {\r\n\r\n\t\t\tcase \"book\":\r\n\t\t\t\tthis.lastFilledObject =  new Book;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase \"author\":\r\n\t\t\t\tthis.lastFilledObject =  new Author;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase \"genre\":\r\n\t\t\t\tthis.lastFilledObject =  new Genre;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Заполнение созданного объекта\r\n\t\tthis.fillObject();\r\n\r\n\t\t// Поиск дубликатов. Если находим дубликат объекта - метод заканчивает работу.\r\n\t\tif (this.findDublicate(dublicateKey)) { \r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// Очистка полей ввода формы\r\n\t\tthis.cleanInputs();\r\n\t\t\r\n\t\t// Добавляем настроенный объект в базу данных.\r\n\t\tthis.addToDatabase();\r\n\r\n\t\t//Возвращаем созданный объект\r\n\t\treturn this.lastFilledObject;\r\n\t}\r\n\t\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод для заполнения объекта значениями с полей ввода в форме (input)\r\n\t * @param {number} id id объекта, который будет заполняется. (По умолчанию генерируется новый)\r\n \t * @return {object} Возвращает заполненный объект\r\n\t */\r\n\tfillObject(id){\r\n\t\t\r\n\t\tlet elements = this.currentForm.elements, // Список эллементов формы\r\n\t\t\tfillableObject, // Объект, который будет заполнен и возвращен методом.\r\n\t\t\taccumulateValues = \"\"; // Переменная, куда будут накапливаться значения в случае множественного выбора из <select>\r\n\r\n\r\n\t\t// Очищаем свойство \"this.lastFilledObject\" от старых значений. \r\n\t\tfor (var prop in this.lastFilledObject) delete this.lastFilledObject[prop];\r\n\r\n\t\t// Если мы передали \"id\" заполняемого объекта -- используем его в качестве id, если нет --генерируем новый id\r\n\t\tif (id) {\r\n\t\t\tthis.lastFilledObject[this.idName] = parseInt(id);\r\n\t\t}else{\r\n\t\t\t// Создаем и заполняем ID объекта\r\n\t\t\tthis.lastFilledObject[this.idName] = this.getID();\r\n\t\t}\r\n\t\t\r\n\t\t// Перебираем все поля ввода\r\n\t\tfor (let i = 0; i < elements.length; i++) {\r\n\t\t\t// console.dir(elements[i]);\r\n\t\t\t// Если элемент формы не имеет атрибута 'ignore'-- заполняем объект, если атрибут имеется -- игнорируем заполнения объекта\r\n\t\t\tif (elements[i].hasAttribute('ignore') == false) {\r\n\r\n\t\t\t\t// Если элемент типа \"select\" имеет атрибут \"multiple\" (Если присутствует множественный выбор)\r\n\t\t\t\tif (elements[i].type == \"select-multiple\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Перебираем в данном элементы все выбранные <option>\r\n\t\t\t\t\tfor (let k = 0; k < elements[i].selectedOptions.length; k++) {\r\n\r\n\t\t\t\t\t\t// и конкатенируем их в переменную \"accumulateValues\"\r\n\t\t\t\t\t\taccumulateValues += `${elements[i].selectedOptions[k].value}, \\n`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// После этого создаем свойство в объекте и записываем результат конкатенации в это свойство.\r\n\t\t\t\t\tthis.lastFilledObject[elements[i].getAttribute(\"id\")] = accumulateValues;\r\n\r\n\t\t\t\t// Иначе просто создаем свойство у объекта с таким же именем, как и значение \"id\" в input\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.lastFilledObject[elements[i].getAttribute(\"id\")] = elements[i].value;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t}\r\n\r\n\t\t// Клонируем объект, чтобы метод смог его вернуть;\r\n\t\tfillableObject = Object.assign({},this.lastFilledObject)\r\n\t\treturn fillableObject;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод очищает все поля текущей формы.\r\n\t * @todo Передлелать этот метод через цикл \"forEach\" или \"for in \"\r\n\t * @return Ничего не возвращает\r\n\t */\r\n\r\n\tcleanInputs(){\r\n\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\r\n\t\t\t// Если поле скрытое, или элемент формы — кнопка, то пропускаем и не очищаем эти элементы\r\n\t\t\tif (!(this.currentForm.elements[i].type == \"hidden\" || this.currentForm.elements[i].localName == \"button\" )) {\r\n\t\t\t\tthis.currentForm.elements[i].value = \"\";\r\n\t\t\t\tthis.currentForm.elements[i].className = \"inputs-clean\" ;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Вариант1\r\n\t\t// for (const key in form.elements) {\r\n\t\t// \tif (form.elements.hasOwnProperty(key)) {\r\n\t\t// \t\tif (key.type != \"hidden\" || key.localName != \"button\") {\r\n\t\t// \t\t\tkey.value = \"\";\r\n\t\t// \t\t\tkey.className = \"inputs-clean\" \r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// }\r\n\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Вариант2\r\n\t\t// form.elements.forEach(element => {\r\n\t\t// \tif (element.type != \"hidden\" || element.localName != \"button\") {\r\n\t\t// \t\telement.value = \"\";\r\n\t\t// \t\telement.className = \"inputs-clean\" \r\n\t\t// \t}\r\n\t\t// });\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод устанавливает, объект какого типа заполнятся в форме. Для работы метода в форме должно быть поле <input type='hidden' id='objtype' value=''>, иначе метод выбросит исключение.\r\n\t * @return {string} Возвращает тип объекта, который заполняется в текущую форму\r\n\t */\r\n\tgetObjectType(){\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\t\t\tif (this.currentForm.elements[i].id == \"objtype\") {\r\n\t\t\t\treturn this.currentForm.elements[i].value\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow \"Не найдено поле ввода  <input type='hidden'> с указанием типа объекта, который будет передан в базу данный. Добавьте в вашу форму поле <input type='hidden' id='objtype' value=''>  В поле value='' укажите тип объекта, который будет добавлен в базу данных\"\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод проверяет дубликаты объектов. В случае нахождения дубликата выводит сообщение.\r\n\t * @param {string} dublicateKey название поля объекта, по которобу будет происходить поиск дубликатов. \r\n\t * @return {boolean} true, если дубликат найден, false — если не нашел.\r\n\t */\r\n\tfindDublicate(dublicateKey = this.idName){\r\n\r\n\t\tlet flag;\r\n\r\n\t\tif (!(this.dataArray)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// Тут производится сравнение по полю \"dublicateKey\". Если есть совпадение — считается, что найден дубликат и метод выводит сообщение.\r\n\t\tflag = this.dataArray.some(item =>item[dublicateKey] == this.lastFilledObject[dublicateKey]);\r\n\t\tif (flag) {\r\n\t\t\talert (\"такая запись уже есть\");\r\n\t\t}\r\n\t\treturn flag;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t//TODO Посмотреть метод validate\r\n\t/**\r\n\t * Метод проверяет форму на валидность (чтобы все необходимые поля были заполнены минимум 1 символом). \r\n\t * @return {boolean} \"true\", если все поля валидные. \"false\", если хотя-бы 1 поле не прошло проверку (тогда и форма считается не валидной)\r\n\t */\r\n\tvalidate() {\r\n\t\t\r\n\t\tlet counterOfInvalid = 0, // Счетчик полей, которые не прошли валидацию\r\n\t\t\telements = this.currentForm.elements; // Список элементов формы\r\n\r\n\t\tfor (let i = 0; i < elements.length; i++) {\r\n\r\n\t\t\tlet pattern \t = elements[i].dataset.pattern, // регуляр. выраж., по которому будет происходить проверка валидации.\r\n\t\t\t\tmessage \t = elements[i].dataset.message, // Сообщение, которое выводится в случае невалидности элемента\r\n\t\t\t\tboundId\t\t = elements[i].dataset.boundId, // id элемента, в который выводить сообщении\r\n\t\t\t\tboundElement = document.querySelector(`#${boundId}`), // элемент, в который будет выводится сообщение\r\n\t\t\t\tvalid \t\t = elements[i].value.search(pattern); // соответствие введеного значения -- паттерну\r\n\r\n\t\t\t// Валидацию будет проходить только тот элемент, у которого имеется свойство \"pattern\"\r\n\t\t\tif (pattern) {\r\n\r\n\t\t\t\tif (valid == -1) {\r\n\r\n\t\t\t\t\telements[i].className = \"inputs-invalid\"\r\n\r\n\t\t\t\t\tif (boundElement) boundElement.innerHTML = message;\r\n\t\t\t\t\r\n\t\t\t\t\tcounterOfInvalid++;\r\n\t\t\t\t}else{\r\n\t\t\t\t\telements[i].className = \"inputs-valid\"\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Если счетчик невалидных элементов больше нуля — то и сама форма невалидная (вернуть \"false\")\r\n\t\tif (counterOfInvalid > 0) {\r\n\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод перезаписывает Local Storage переданным в параметре объектом.\r\n\t * @param {Array} newArray новый массив данных, которым нужно перезаписать Local Storage\r\n\t * @return {Array} Возращает новый, перезаписанный массив с Local Storage\r\n\t */\r\n\toverwriteLocalStorage(newArray){\r\n\r\n\t\tif (this.needAddToLocalStorege) {\r\n\t\t\tlocalStorage.setItem(this.localStorageKey, JSON.stringify(newArray));\r\n\t\t\treturn JSON.parse(localStorage.getItem(this.localStorageKey))\r\n\t\t}else{ // Случай, если мы не работаем с localStorage, но метод был вызван.\r\n\t\t\tconsole.warn(`Свойство ${this}.needAddToLocalStorege в значении ${this.needAddToLocalStorege}. Не удалось записать в Local Storage`); \r\n\t\t\treturn newArray;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод  добавляет переданный в параметре объект -- в Local Storage.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\taddToDatabase(object = this.lastFilledObject) {\r\n\r\n\t\t// Добавляем переданный объект \"object\" в масиив данных \"this.dataArray\"\r\n\t\tthis.dataArray.push(object);\r\n\r\n\t\t// Перезаписываем LocalStorage\r\n\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который удаляет объект из базы данных, который был передан в параметре.\r\n\t * @param {object} object Объект, который необходимо удалить. По умолчанию \"this.selectedObject\"\r\n\t * @return {Array} Возвращает актуальный массив данных. (или false, если нет объекта для удаления)\r\n\t */\r\n\tdeleteObject(object = this.selectedObject){\r\n\t\t\r\n\t\tif (object) {\r\n\t\t\tthis.dataArray.splice(this.findObject(object), 1);\r\n\t\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t\t}else{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который изменяет объект в базе данных, который был передан в параметре.\r\n\t * @param {object} object Объект, который необходимо изменить. По умолчанию \"this.selectedObject\"\r\n\t * @return {Array} Возвращает актуальный массив данных. \r\n\t */\r\n\teditObject(object = this.selectedObject){\r\n\r\n\t\tlet copiedObject; // Переменная, чтобы склонировать объект \"this.lastFilledObject\"\r\n\t\t\r\n\t\tif (object) {\r\n\t\t\tthis.fillObject(object[this.idName])\r\n\r\n\t\t\t// Клонируем объект \"this.lastFilledObject\", для того, чтобы избавиться от копирования по ссылке.\r\n\t\t\tcopiedObject = Object.assign({},this.lastFilledObject)\r\n\r\n\t\t\tthis.dataArray[this.findObject(object)] = copiedObject; \r\n\t\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод находит индекс переданного в параметре объекта в текущем массиве данных (dataArray)\r\n\t * @param {object} object Объект, который нужно найти в массиве данных.\r\n\t * @return {number} Возвращает индекс объекта, который был передан в параметр.\r\n\t */\r\n\tfindObject(object){\r\n\r\n\t\treturn  this.dataArray.findIndex((item)=>{\r\n\t\t\t// Если совпадают значения \"id\" в переданном объекте и в массиве данных -- возращаем индекс. \r\n\t\t\treturn item[this.idName] == object[this.idName]\r\n\t\t})\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t *  Метод формирует уникальный идентификатор для нового объекта.\r\n\t * @return {number} Возращает новое значение \"id\", которого еще не было (самое большое текущее \"id\" +1)\r\n\t */\r\n\tgetID() {\r\n\r\n\t\tlet currentId = 0; // Текущий \"id\"\r\n\r\n\t\t// Если у нас присудствует массив с данными, то...\r\n\t\tif (this.dataArray) {\r\n\t\t\t// ...ищем самое большое значение \"id\"\r\n\t\t\tthis.dataArray.forEach(element => {\r\n\t\t\t\t\r\n\t\t\t\tif( parseInt(element[this.idName])  > currentId){\r\n\t\t\t\t\tcurrentId  = parseInt(element[this.idName])\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t// И возвращаем на 1 больше\r\n\t\t\treturn currentId + 1;\r\n\r\n\t\t// Если данных нет -- возвращаем просто 1 (предпологается что это запрос перед созданием массива с данными)\r\n\t\t}else{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * Метод формирует ключ для LocalStorage.\r\n\t * @param {string} postfix Постфикс (Часть, которая указывается в названии ключа после типа объекта для создания имени ключа LocalStorage (по умолчанию \"-library\"))\r\n\t * @return {string} Возвращает созданный ключ для LocalStorage.\r\n\t */\r\n\tgetLocalStorageKey(postfix = \"-library\"){\r\n\r\n\t\t//Находим в форме поле ввода с id == \"objtype\" (это поле типа  \"hidden\")\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\t\t\tif (this.currentForm.elements[i].id == \"objtype\") {\r\n\t\t\t\t\r\n\t\t\t\t// Возвращаем созданный  ключ\r\n\t\t\t\treturn this.currentForm.elements[i].value + postfix;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow \"Метод не смог найти поле с id == 'objtype' и value == '<название вашего объекта>'. Убедитесь что оно есть \"\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * Метод находит поле для ввода, у которого есть привязка к данным в базе данных и заполняет данными.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tcheckForm(){\r\n\r\n\t\tlet localStorageKeyBind,\r\n\t\t\tobjectPropertyBind ,\r\n\t\t\tarrayOfObjects;\r\n\r\n\t\t// Перебираем все элементы формы\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\r\n\t\t\tlocalStorageKeyBind = this.currentForm.elements[i].dataset.localStorageKeyBind;\r\n\t\t\tobjectPropertyBind = this.currentForm.elements[i].dataset.objectPropertyBind;\r\n\t\t\tarrayOfObjects = JSON.parse(window.localStorage.getItem(localStorageKeyBind));\r\n\r\n\t\t\t// Если перебираемое поле для ввода содержит какую -либо из привязок -- тогда заполняем это поле объектами \r\n\t\t\tif (localStorageKeyBind && objectPropertyBind) {\r\n\t\t\t\tthis.fillInput(this.currentForm.elements[i], arrayOfObjects);\r\n\r\n\t\t\t// Если пользователь привязал что-то одно (из двух необходимых атрибутов) -- выбрасываем исключение\r\n\t\t\t} else if(localStorageKeyBind){\r\n\t\t\t\tthrow \"Нет привязки к свойству объекта. Укажите в HTML элементе атрибут <objectPropertyBind> со значением свойства объекта, которое необходимо выводить.\"\r\n\t\t\t} else if(objectPropertyBind){\r\n\t\t\t\tthrow \"Нет привязки к Массиву объектов в LocalStorage. Укажите атрибут <localStorageKeyBind> со значением ключа, из которого необходимо получить данные для привязки.\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет элемент формы значениями с массива.\r\n\t * @param {object} element Елемент формы, который необходимо заполнить\r\n\t * @param {Array} arrayOfObjects Массив объектов, из которых нужно взять необходимое значение\r\n\t * @return {object} возвращает заполненный элемент\r\n\t */\r\n\tfillInput(element, arrayOfObjects){\r\n\r\n\t\tlet bindingKey = element.dataset.objectPropertyBind; // Свойство объекта, из которого необходимо взять значение и заполнить в элемент.\r\n\t\tlet elementType = element.tagName.toLowerCase(); // Тип  DOM-элемента\r\n\r\n\t\tif (arrayOfObjects) {\r\n\t\t\tswitch (elementType) {\r\n\r\n\t\t\t\t// пока метод реализован только чтобы заполнять <select> \r\n\t\t\t\tcase \"select\":\r\n\t\t\t\t\tfor (let i = 0; i < arrayOfObjects.length; i++) {\r\n\t\t\t\t\t\tlet optionElement = document.createElement(\"option\");\r\n\r\n\t\t\t\t\t\toptionElement.value = arrayOfObjects[i][bindingKey];\r\n\t\t\t\t\t\toptionElement.innerHTML = arrayOfObjects[i][bindingKey];\r\n\t\t\t\t\t\telement.appendChild(optionElement);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn element;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\treturn false;\r\n\t\t}\t\r\n\t}\r\n\r\n\t/**\r\n\t * Метод заполняет поля текущей формы (всей формы) значениями из объекта\r\n\t * @param {object} fillingObject Объект для заполнения формы. \r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tfillForm(fillingObject){\r\n\r\n\t\t// Перебираем все элементы формы\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\r\n\t\t\t// Если поле не скрытое, или элемент формы — не кнопка\r\n\t\t\tif (!(this.currentForm.elements[i].type == \"hidden\" || this.currentForm.elements[i].localName == \"button\" )) {\r\n\r\n\t\t\t\t// перебираем все свойства объекта \"fillingObject\"\r\n\t\t\t\tfor (const key in fillingObject) {\r\n\r\n\t\t\t\t\t// Если название свойства объекта соответсвует значению \"id\" в input-те\r\n\t\t\t\t\tif (key == this.currentForm.elements[i].id){\r\n\r\n\t\t\t\t\t\t// тогда заполняем поле значением со свойсва объекта.\r\n\t\t\t\t\t\tthis.currentForm.elements[i].value = fillingObject[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nclass Book{\r\n\t// Конструктор не применялся. Новый объект \"book\" заполняется с помощью цикла\r\n/* \tconstructor(id, name, author){\r\n\t\tthis.id = id;\r\n\t\tthis.name = name;\r\n\t\tthis.author = author;\r\n\r\n\t} */\r\n\r\n\t// constructor(array){\r\n\r\n\t// \tfor (let i = 0; i < array.length; i++) {\r\n\t\t\t\r\n\t// \t}\r\n\t// \t// array.forEach(element => {\r\n\t// \t// \telement.id = id;\r\n\t// \t// \telement.name = name;\r\n\t// \t// \telement.author = author;\r\n\t// \t// });\r\n\t// }\r\n\r\n}\r\n\r\nexport {Book};","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nexport class Genre{\r\n}\r\n","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nexport class Author{\r\n}\r\n"],"sourceRoot":""}