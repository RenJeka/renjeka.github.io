{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/myHelperLib.js","webpack:///./src/table.class.js","webpack:///./src/form.class.js","webpack:///./src/objectsClasses/books.class.js","webpack:///./src/objectsClasses/genres.class.js","webpack:///./src/objectsClasses/authors.class.js","webpack:///./src/indexGenre.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","$","selector","document","querySelector","Table","currentTable","formObject","tableData","this","boundForm","currentForm","localStorageKey","arrayOfObservers","sortMark","sortDirection","otherRowSelectHandler","selectedObject","observers","forEach","element","push","observerUpdate","onclick","rowSelectHandler","length","addRows","rowIndex","getTableData","fasle","jsonObject","localStorage","getItem","JSON","parse","some","elem","sort","sortFunc1","undefined","dataInRow","numberOfRows","numberOfCells","arrayofRows","row","add","context","createElement","tBodies","appendChild","j","cell","addInfoInRow","rows","cells","indexOfRow","addInfoInCell","indexOfCell","toLowerCase","getTableColumnHead","innerHTML","dataset","objectKeyBind","parseInt","deleteRow","input","objectProperty","filter","trim","includes","console","log","callbackHandler","eventObject","returnedValue","target","tagName","cleanTable","fillTable","parentElement","fillForm","setClassToElement","notify","applyingСlass","className","a","b","Form","idName","dataArray","getLocalStorageKey","needAddToLocalStorege","window","lastFilledObject","dublicateKey","validate","getObjectType","Book","Author","Genre","fillObject","findDublicate","cleanInputs","addToDatabase","id","elements","accumulateValues","prop","getID","hasAttribute","type","k","selectedOptions","getAttribute","assign","localName","flag","item","alert","counterOfInvalid","pattern","message","boundId","boundElement","valid","search","newArray","setItem","stringify","warn","overwriteLocalStorage","splice","findObject","copiedObject","findIndex","currentId","postfix","localStorageKeyBind","objectPropertyBind","arrayOfObjects","fillInput","bindingKey","elementType","optionElement","fillingObject","addEventListener","formGenre","forms","tableGenre","checkForm","addObservers","returnedObject","addButtonHandler","editObject","deleteObject","e","searchObjectProperty","tableClickHandler"],"mappings":"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","file":"indexGenre.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","//  Моя вспомогательная библиотека. Тут находятся функции-помощники, чтобы не подключать JQuery.\r\n\r\nfunction $(selector) {\r\n\treturn document.querySelector(selector);\r\n}\r\n\r\nexport {$};","import { $ } from \"./myHelperLib\";\r\n\r\n/**\r\n * Класс для создания объекта \"Таблица\"\r\n * Объект таблица является Наблюдаемым объектом (Observable) \r\n */\r\nexport class Table{\r\n\r\n\t/**\r\n\t * Конструктор. Создает объект -- таблица, которая подвязывается под 1 HTML-таблицу\r\n\t * @param {String} currentTable CSS -селектор для нахождения нужной (связанной таблицы)\r\n\t * @param {object} formObject Объект формы, созданный классом \"Form\"\r\n\t * @param {Array} tableData -- Массив объектов, которыми будет заполнятся таблица\r\n\t */\r\n\tconstructor(currentTable,formObject,tableData){\r\n\t\tthis.currentTable = $(currentTable);\r\n\t\tthis.formObject = formObject;\r\n\t\tthis.tableData = tableData;\r\n\r\n\t\t/**\t\r\n\t\t * Привязанная форма под данную таблицу. Объект класса \"Form\".\r\n\t\t */\r\n\t\tthis.boundForm = formObject.currentForm;\r\n\r\n\t\t/**\r\n\t\t * Ключ от localStorage, где хранится массив данных с объектами, которые представлены в данной таблице\r\n\t\t */\r\n\t\tthis.localStorageKey = formObject.localStorageKey\r\n\r\n\t\t/**\t\r\n\t\t * Список подписчиков (паттерн Observer)\r\n\t\t */\r\n\t\tthis.arrayOfObservers = [];\r\n\r\n\t\t/**\r\n\t\t * Свойство, которое содержит значение, по которому будут отсортированны данные в таблице\r\n\t\t */\r\n\t\tthis.sortMark;\r\n\r\n\t\t/**\r\n\t\t * Свойство, которое содержит направление сортировки данных в таблице. (прямое или обратное)\r\n\t\t */\r\n\t\tthis.sortDirection = true;\r\n\r\n\t\t/**\t\r\n\t\t * Свойство, которое содержит пользовательский обработчик событий (при клике на строку таблицы)\r\n\t\t */\r\n\t\tthis.otherRowSelectHandler;\r\n\r\n\t\t/**\r\n\t\t * Текущий объект, который в данный момент выделен пользователем в таблице\r\n\t\t */\r\n\t\tthis.selectedObject;\r\n\t}\r\n\r\n\t/**\r\n\t * Метод добавляет подписчика в массив подписчиков (паттерн Observer)\r\n\t * @param {object} observers (rest-параметр) Подписчики (наблюдатели) за изменениями\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\taddObservers(...observers){\r\n\t\tobservers.forEach(element => {\r\n\t\t\tthis.arrayOfObservers.push(element);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Метод - уведомление подписчиков об изменениях (паттерн Observer). Этот метод создаваля для синхронизации параметра \"tableData\" и обработчика выбора строки \"rowSelectHandler\". Здесь объект класа Table ОДНОВРЕМЕННО и ИЗДАТЕЛЬ и ПОДПИСЧИК.\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\tnotify(){\r\n\t\tthis.arrayOfObservers.forEach(element => {\r\n\t\t\telement.observerUpdate({currentTable: this.currentTable, tableData: this.tableData, selectedObject: this.selectedObject})\r\n\t\t});\r\n\t\t// console.log(`selectedObject = `, this.selectedObject);\r\n\t}\r\n\t\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод update паттерна Observer\r\n\t * @return {void} Ничего не возвращает.\r\n\t */\r\n\tobserverUpdate(){\r\n\t\tif (this.otherRowSelectHandler) {\r\n\t\t\tthis.currentTable.onclick = this.otherRowSelectHandler.bind(this);\r\n\t\t}else{\r\n\t\t\tthis.currentTable.onclick = this.rowSelectHandler.bind(this);\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет указанную таблицу, взяв данные с LocalStorage по ключу, либо указанным ранее массивом объектов.\r\n\t * @return {void} Возвращает массив с данными, которыми была заполнена таблица.\r\n\t */\r\n\tfillTable(sortMark,sortDirection) {\r\n\t\r\n\t\tif (sortMark) {\r\n\t\t\tthis.sortMark = sortMark;\r\n\t\t}\r\n\t\tif (sortDirection) {\r\n\t\t\tthis.sortDirection = sortDirection;\r\n\t\t}\r\n\t\t\r\n\t\t// Если у нас есть связанная таблица и готовый массив с данными для заполнения таблицы\r\n\t\tif (this.currentTable && this.tableData) {\r\n\t\t\t\r\n\t\t\t// Заполняем таблицу данными\r\n\t\t\tfor (let i = 0; i < this.tableData.length; i++) { // ? ForEach? \r\n\t\t\t\tthis.addRows(this.tableData[i]).rowIndex; \r\n\t\t\t}\r\n\r\n\t\t\t//Возвращаем массив, которым заполнили таблицу\r\n\t\t\treturn this.tableData;\r\n\r\n\t\t// Если у нас есть связанная таблица и ключ от localStorage\r\n\t\t}else if (this.currentTable && this.localStorageKey) {\r\n\r\n\t\t\t// Достаем данные из localStorage\r\n\t\t\tthis.tableData = this.getTableData();\r\n\r\n\t\t\t// Проверка на наличие данных в localStorage //TODO Проверить, правильная ли проверка\r\n\t\t\tif (this.tableData == false) {\r\n\r\n\t\t\t\t// Если в localStorage пустой массив -- возвращаем false\r\n\t\t\t\treturn false; \r\n\t\t\t}\r\n\r\n\t\t\t// Заполняем таблицу данными\r\n\t\t\tfor (let i = 0; i < this.tableData.length; i++) { // ? ForEach? \r\n\t\t\t\tthis.addRows(this.tableData[i]).rowIndex; \r\n\t\t\t}\r\n\r\n\t\t\t//Возвращаем массив, которым заполнили таблицу\r\n\t\t\treturn this.tableData;\r\n\r\n\t\t}else{\r\n\r\n\t\t\t// Если таблица не подвязана -- выброс исключения\r\n\t\t\tif (this.currentTable == false) {\r\n\t\t\t\tthrow `Не найдена связанная HTML-таблица. Пожалуйста добавьте HTML-таблицу в свойство ${this}.currentTable `;\r\n\r\n\t\t\t// Если у нас нет ни массива с данными, ни ключа localStorage -- выброс исключения\r\n\t\t\t}else if (this.localStorageKey == fasle && this.tableData == fasle) {\r\n\t\t\t\t\r\n\t\t\t\tthrow `Не найдены данные для заполнения HTML-таблицы. Пожалуйста добавте данные. Если у вас массив с данными -- добавьте этот массив в свойство  ${this}.tableData, если у вас данные в LocalStorage -- добавте ключ к данным в свойство ${this}.localStorageKey`;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод позволяет получить данные с LocalStorage для заполнения таблицы.  \r\n\t * @return {Object} Возвращает массив объектов, которым можно заполнить таблицу, или false, если не смог найти его в localStorage.\r\n\t */\r\n\tgetTableData() { \r\n\r\n\t\tlet jsonObject = localStorage.getItem(this.localStorageKey);\r\n\r\n\t\t// Если есть JSON-данные по переданному ключу — тогда возвращаем подготовленные данные, если JSON не найден — возвращаем false.\r\n\t\tif (jsonObject) {\r\n\r\n\t\t\t// Парсим данные из localStorage. Получаем массив с объектами\r\n\t\t\tjsonObject = JSON.parse(jsonObject);\r\n\r\n\t\t\t// Если поле для сортировки \"this.sortMark\" соответствует свойству в объекте\r\n\t\t\tif (jsonObject.some((elem)=>elem[this.sortMark])) {\r\n\r\n\t\t\t\t//Возвращаем отсортированный массив по заранее заданной функции\r\n\t\t\t\treturn jsonObject.sort(this.sortFunc1.bind(this)) \r\n\r\n\t\t\t// Если нет значения для сортировки \"this.sortMark\" — Возвращаем неотсортированный массив.\r\n\t\t\t}else if(this.sortMark == undefined){\r\n\t\t\t\treturn jsonObject;\r\n\r\n\t\t\t// Если значения для сортировки \"this.sortMark\" не верное — выбрасываем исключение. \r\n\t\t\t}else{\r\n\t\t\t\tthrow \"Значение, переданное для сортировки — не верное. Такого свойства у объекта нет.\"\r\n\t\t\t}\r\n\r\n\t\t}else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который добавляет ряды с ячейками в таблицу\r\n\t * @todo реализовать метод без замыкания (без внутреней функции)\r\n\t * @param {object} dataInRow Данные для 1 строки (1 объект)\t \r\n\t * @param {Number} numberOfRows Кол-во рядов (по умолчанию = 1)\r\n\t * @param {Number} numberOfCells Кол-во ячеек в ряде (По умолчанию высчитывается по кол-ву ячеек в заголовке (thead))\r\n\t * @return {arrayofRows} Возвращает созданный массив строк (либо 1 строку) с данными.\r\n\t */\r\n\taddRows(dataInRow, numberOfRows = 1, numberOfCells) {\r\n\t\t\r\n\t\tlet arrayofRows = [], // Массив будущих строк\r\n\t\t\trow; // Текущая строка\r\n\r\n\t\t// Эта функция собственно и добавляет ряд, ячейки и текст в таблицу. Принимает контекст, и возвращает массив с созданными строками\r\n\t\tfunction add(context) {\r\n\t\t\t\r\n\t\t\t// Цикл добавляеи по 1-й строке то кол-во, которое мы укажем (numberOfRows)\r\n\t\t\tfor (let i = 0; i < numberOfRows; i++) {\r\n\r\n\t\t\t\trow = document.createElement(\"tr\")\r\n\t\t\t\tcontext.currentTable.tBodies[0].appendChild(row)\r\n\r\n\t\t\t\t// Цикл добавляет по 1-й ячейке то кол-во, которое мы укажем (numberOfCells)\r\n\t\t\t\tfor (let j = 0; j < numberOfCells; j++) {\r\n\r\n\t\t\t\t\tlet cell = document.createElement(\"td\")\r\n\t\t\t\t\trow.appendChild(cell)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tarrayofRows.push(row);\r\n\t\t\t\t\r\n\t\t\t\tif (dataInRow) {\r\n\t\t\t\t\tcontext.addInfoInRow(row.rowIndex, dataInRow);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn arrayofRows;\r\n\t\t}\r\n\r\n\t\t// Проверка на наличие аргумента \"numberOfCells\", если его нет— за количестко ячеек высчитывается из количества ячеек первого ряда (из \"thead\");\r\n\t\tif (numberOfCells == undefined) {\r\n\t\t\tnumberOfCells = this.currentTable.rows[0].cells.length;\r\n\t\t}\r\n\r\n\t\t// Этот способ будет использоваться чаще всего и возвращать 1 созданный ряд с данными.\r\n\t\tif (numberOfRows == 1) {\r\n\r\n\t\t\tarrayofRows = add(this) // ? return add(this)[0] -- попробовать вернуть это\r\n\t\t\treturn arrayofRows[0];\r\n\t\t}\r\n\t\treturn add(this);\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * метод, который заполняет ряд таблицы. Использует метод \"addInfoInCell\", который заполняет каждую ячейку\r\n\t * @param {Number} indexOfRow Индекс ряда в таблице, который будет заполнятся данными \r\n\t * @param {Object} object Объект с данными для заполнения ряда. \r\n\t * @return {void} Ничего не возвращает\r\n\t*/\r\n\taddInfoInRow(indexOfRow, object) {\r\n\r\n\t\tfor (let i = 0; i < this.currentTable.rows[indexOfRow].cells.length; i++) {\r\n\t\t\tthis.addInfoInCell(object, indexOfRow, i)\r\n\t\t}\r\n\t}\r\n\r\n// ---------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет одну указанную ячейку в указанном ряде таблицы. Нужен для работы метода addInfoInRow\r\n\t * @param {Object} object Объект с данными для заполнения ячейки.\r\n\t * @param {Number} indexOfRow Индекс ряда, в котором находится нужная для заполнения ячейка\r\n\t * @param {Number} indexOfCell Индекс ячейки, которая будет заполнятся.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\taddInfoInCell(object, indexOfRow, indexOfCell) {\r\n\r\n\t\tfor (const key in object) {\r\n\t\t\tif (object.hasOwnProperty(key)) {\r\n\r\n\t\t\t\t// Если ключ объекта равняется тому, что вернул метот \"getTableColumnHead\" — значение из объекта заполняется в заранее заданную ячейку\r\n\t\t\t\tif (key.toLowerCase() === this.getTableColumnHead(indexOfCell).toLowerCase()){\r\n\r\n\t\t\t\t\tthis.currentTable.rows[indexOfRow].cells[indexOfCell].innerHTML = object[key];\r\n\r\n\t\t\t\t\t// Возвращаем заполненную ячейку\r\n\t\t\t\t\treturn this.currentTable.rows[indexOfRow].cells[indexOfCell]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод вычисляет, какой заголовок находиться над указанной ячейкой (Заголовок колонки). Нужен для работы метода \"addInfoInCell\"\r\n\t * @param {Number} indexOfCell Индекс ячейки, у которой необходимо узнать заголовок.\r\n\t * @return {String} Возвращает название заголовка над ячейкой.\r\n\t * @see addInfoInCell\r\n\t */\r\n\tgetTableColumnHead(indexOfCell) {\r\n\r\n\t\t// Получаем значение из атрибута \"data-object-key-bind\" в заголовочной ячейки\r\n\t\tlet nameOfTableHead = this.currentTable.rows[0].cells[indexOfCell].dataset.objectKeyBind;\r\n\t\treturn nameOfTableHead;\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод полностью очищает конкретный ряд либо таблицу целиком\r\n\t * @param {number} indexOfRow Индекс строки, которую нужно удалить. Если параметр отсутствует --таблица очистится полностью.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tcleanTable(indexOfRow){\r\n\r\n\t\tindexOfRow = parseInt(indexOfRow);\r\n\r\n\t\tif (indexOfRow) {\r\n\t\t\t// Проверка, правильно ли введен индекс строки\r\n\t\t\tif (indexOfRow <= this.currentTable.rows.length -1  && indexOfRow >= 0) {\r\n\r\n\t\t\t\t// Удаляем строку по индексу \"indexOfRow\"\r\n\t\t\t\tthis.currentTable.deleteRow(indexOfRow)\r\n\t\t\t}else{\r\n\t\t\t\tthrow \"Невозможно удалить строку. Такой строки не существует. Проверьте правильность передаваемого в параметр значения.\"\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t// Запускаем цикл на иттераций равную кол-во строк в таблице. Каждый раз удаляем последнюю строку.\r\n\t\t\twhile (this.currentTable.rows.length > 1) {\r\n\t\t\t\tthis.currentTable.deleteRow(this.currentTable.rows.length - 1);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод поиска. Фильтрует массив по значению input.value, и возвращает его.\r\n\t * @param {object} input Элемент, в который вводится фильтрирующее значение.\r\n\t * @param {string} objectProperty свойство (название свойства) объекта, по которому будет происходить фильтрация.\r\n\t * @return {Array} Возвращает отфильтнованный массив либо false, если массив не удалось найти.\r\n\t */\r\n\tsearch(input, objectProperty){\r\n\t\tlet tempVariable;\r\n\t\tthis.tableData = this.getTableData();\r\n\r\n\t\tif(this.tableData){\r\n\r\n\t\t\ttempVariable = this.tableData.filter(element => {\r\n\r\n\t\t\t\t// Переводим значение свойства объекта в нижний регистр \r\n\t\t\t\tlet tempProperty = element[objectProperty].trim().toLowerCase();\r\n\t\t\t\t// Если \"tempProperty\" содержит то, что мы ввели в \"input\" -- значит это искомое значение.\r\n\t\t\t\treturn tempProperty.includes(input.value.trim().toLowerCase());\r\n\t\t\t});\r\n\t\t\treturn tempVariable;\r\n\t\t\t  \r\n\t\t}else{\r\n\t\t\tconsole.log (\"Не удалось найти массив с данными\")\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод запускает обработчик события по клику на строку. Можно подвесить свой обработчик (callbackHandler)\r\n\t * @param {Function} callbackHandler Функция, которая ставится в качестве обработчика на нажатие по таблице. (По умолчанию this.rowSelectHandler)\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\ttableClickHandler(callbackHandler){\r\n\r\n\t\tthis.otherRowSelectHandler = callbackHandler;\r\n\r\n\t\tif (this.otherRowSelectHandler) {\r\n\t\t\tthis.currentTable.onclick = this.otherRowSelectHandler.bind(this);\r\n\t\t}else{\r\n\t\t\tthis.currentTable.onclick = this.rowSelectHandler.bind(this);\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод обрабатывает клик по строке. Его задача отсортировать таблицу, если клик был по заголовку, или вернуть строку, если клик был по \"не заголовочной\" строке.\r\n\t * @todo Ножна ли тут переменная \"returnedValue\" ?\r\n\t * @param {object} eventObject Объект события, который передается при клике.\r\n\t * @return {object} Возвращщает массив с данными после сортировки, либо объект, на который кликнул пользователь.\r\n\t */\r\n\trowSelectHandler(eventObject){\r\n\r\n\t\tlet returnedValue; // Значение, которое возвращает этот метод.\r\n\t\t\r\n\t\tthis.sortMark = eventObject.target.dataset.objectKeyBind;\r\n\t\t\t\r\n\t\t// Проверка, если есть атрибут \"objectKeyBind\" у HTML элемента -- сортируем таблицу\r\n\t\tif (this.sortMark && eventObject.target.tagName == \"TH\") {\r\n\r\n\t\t\tthis.sortDirection = !this.sortDirection;\r\n\t\t\t\r\n\t\t\t// Сортируем текущие данные. (Учитывая потерю контекста)\r\n\t\t\tthis.tableData.sort(this.sortFunc1.bind(this));\r\n\r\n\t\t\t// Очищаем всю таблицу\r\n\t\t\tthis.cleanTable();\r\n\r\n\t\t\t// Заполняе новыми значениями (с учетом сортировки)\r\n\t\t\treturnedValue = this.fillTable();\r\n\t\t\tthis.tableData = returnedValue;\r\n\t\t\tthis.selectedObject = null;\r\n\r\n\t\t// Если пользователь кликнул по строке с данными -- находим индекс строки и возвращаем объект с массива объектов (по этому индексу)\r\n\t\t}else if(eventObject.target.tagName == \"TD\"){\r\n\t\t\treturnedValue = this.tableData[eventObject.target.parentElement.rowIndex -1];\r\n\t\t\tthis.selectedObject = returnedValue;\r\n\t\t\tthis.formObject.fillForm(this.selectedObject)\r\n\r\n\t\t\tthis.setClassToElement(eventObject.target.parentElement, \"row-selected\")\r\n\t\t}\r\n\r\n\t\t// по окончанию метода запускаем метод паттерна \"observer\" -- notify() чтобы обновить все данные.\r\n\t\tthis.notify();\r\n\r\n\t\treturn returnedValue;\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который проходится по таблице и применяет стиль к 1 конкретному ряду (строке).\r\n\t * @todo Как установить правильно класс элементу\r\n\t * @param {object} row Ряд к которому необходимо применить клас\r\n\t * @param {string} applyingСlass css клас, который нужно применить к ряду.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tsetClassToElement(row, applyingСlass){\r\n\t\tfor (let i = 0; i<this.currentTable.rows.length ; i++) {\r\n\t\t\tthis.currentTable.rows[i].className = \"\";\r\n\t\t\tif (this.currentTable.rows[i] == row) {\r\n\t\t\t\tthis.currentTable.rows[i].className = applyingСlass;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// -----------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который передается в сортировку массива. Сортирует значения по возрастанию, либо по убыванию в зависимости от значения \"this.sortDirection\".\r\n\t * @param {object} a Первый параметр для сравнения со вторым\r\n\t * @param {object} b Второй параметр для сравнения с первым.\r\n\t */\r\n\tsortFunc1(a, b) { \r\n\r\n\t\tif (this.sortDirection) {\r\n\t\t\tif (a[this.sortMark] >  b[this.sortMark]) return 1; // если первое значение больше второго\r\n\t\t\tif (a[this.sortMark] == b[this.sortMark]) return 0; // если равны\r\n\t\t\tif (a[this.sortMark] <  b[this.sortMark]) return -1; // если первое значение меньше второго\r\n\t\t}else{\r\n\t\t\tif (a[this.sortMark] <  b[this.sortMark]) return 1; \r\n\t\t\tif (a[this.sortMark] == b[this.sortMark]) return 0;\r\n\t\t\tif (a[this.sortMark] >  b[this.sortMark]) return -1;\r\n\t\t}\t\r\n\t}\r\n}","import { Book} from './objectsClasses/books.class';\r\nimport { Genre } from './objectsClasses/genres.class';\r\nimport { Author } from './objectsClasses/authors.class';\r\n\r\n/**\r\n * Класс для создания объекта \"Форма\"\r\n */\r\nexport class Form{\r\n\r\n\t/**\r\n\t * Конструктор класса \"Form\". Создает объект -- Форма, который подвязывается под под 1 HTML -форму.\r\n\t * @param {object} currentForm  Текущая <HTML>-форма, которая привязывается к данному объекту\r\n\t * @param {String} idName название ID для идентификации каждого объекта\r\n\t * @param {Array} dataArray (не обязательный) Массив данных, (набор объектов, что заполняется в форме). По умолчанию данные записываются в  localStorage.\r\n\t */\r\n\tconstructor(currentForm, idName, dataArray){\r\n\t\tthis.currentForm = currentForm;\r\n\t\tthis.idName = idName;\r\n\t\tthis.dataArray = [];\r\n\r\n\t\t/**\t\r\n\t\t * Ключ от localStorage, где хранится массив данных с объектами, которые которые обрабатывает данная форма.\r\n\t\t */\r\n\t\tthis.localStorageKey = this.getLocalStorageKey(\"-library\");\r\n\r\n\t\t/**\t\r\n\t\t * Нужно ли добавлять данные в LocalStorege (true -нужно, false -не нужно)\r\n\t\t */\r\n\t\tthis.needAddToLocalStorege = true;\r\n\r\n\t\t// TODO Как сделать так, чтобы объекты 2 разных классов знали друг о друге сразу, через конструктор. (И нужно ли вообще это?)\r\n\t\t// this.tableObject = tableObject;\r\n\t\t// this.tableObject;\r\n\r\n\t\tif (dataArray) {\r\n\t\t\tthis.dataArray = dataArray;\r\n\t\t\tthis.needAddToLocalStorege = false;\r\n\r\n\t\t}else if(window.localStorage.getItem(this.localStorageKey)){\r\n\t\t\tthis.dataArray = JSON.parse(window.localStorage.getItem(this.localStorageKey));\r\n\t\t}\r\n\t\t/**\t\r\n\t\t * Последний (текущий) объект, который заполнялся.\r\n\t\t */\r\n\t\tthis.lastFilledObject = {}; \r\n\r\n\t\t/**\t\r\n\t\t * Объект, который в текущий момент выбран в таблице.\r\n\t\t */\r\n\t\tthis.selectedObject;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * @param {object} Принимает объект с 4 свойсвами (свойства объекта класса Table) : currentTable - текущая таблица, tableData - текущий массив, которым заполнена таблица, selectedObject - текущий выбранный объект в таблице\r\n\t * Метод подписчика, обновляет данные \"this.selectedObject\"\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tobserverUpdate({currentTable, tableData, selectedObject}){\r\n\t\tthis.selectedObject = selectedObject\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Обработчик событий при нажатии на кнопку добавления объекта в базу данных. Берет с формы данные и записывает в базу данных.\r\n\t * @param {string} dublicateKey Ключ, по которому будет происходить поиск дубликатов (по умолчанию дубликатом считается объект с таким-же ID)\r\n\t * @return {object} Возвращает заполненный объект;\r\n\t */\r\n\taddButtonHandler(dublicateKey = this.idName) {\r\n\r\n\t\t// Проверка валидации. Если валидация вернула \"false\" — то закончить выполнение текущего метода\r\n\t\tif (this.validate() == false) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Проверка и создание объекта нужного типа. \r\n\t\tswitch (this.getObjectType()) {\r\n\r\n\t\t\tcase \"book\":\r\n\t\t\t\tthis.lastFilledObject =  new Book;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase \"author\":\r\n\t\t\t\tthis.lastFilledObject =  new Author;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase \"genre\":\r\n\t\t\t\tthis.lastFilledObject =  new Genre;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Заполнение созданного объекта\r\n\t\tthis.fillObject();\r\n\r\n\t\t// Поиск дубликатов. Если находим дубликат объекта - метод заканчивает работу.\r\n\t\tif (this.findDublicate(dublicateKey)) { \r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t\r\n\t\t// Очистка полей ввода формы\r\n\t\tthis.cleanInputs();\r\n\t\t\r\n\t\t// Добавляем настроенный объект в базу данных.\r\n\t\tthis.addToDatabase();\r\n\r\n\t\t//Возвращаем созданный объект\r\n\t\treturn this.lastFilledObject;\r\n\t}\r\n\t\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод для заполнения объекта значениями с полей ввода в форме (input)\r\n\t * @param {number} id id объекта, который будет заполняется. (По умолчанию генерируется новый)\r\n \t * @return {object} Возвращает заполненный объект\r\n\t */\r\n\tfillObject(id){\r\n\t\t\r\n\t\tlet elements = this.currentForm.elements, // Список эллементов формы\r\n\t\t\tfillableObject, // Объект, который будет заполнен и возвращен методом.\r\n\t\t\taccumulateValues = \"\"; // Переменная, куда будут накапливаться значения в случае множественного выбора из <select>\r\n\r\n\r\n\t\t// Очищаем свойство \"this.lastFilledObject\" от старых значений. \r\n\t\tfor (var prop in this.lastFilledObject) delete this.lastFilledObject[prop];\r\n\r\n\t\t// Если мы передали \"id\" заполняемого объекта -- используем его в качестве id, если нет --генерируем новый id\r\n\t\tif (id) {\r\n\t\t\tthis.lastFilledObject[this.idName] = parseInt(id);\r\n\t\t}else{\r\n\t\t\t// Создаем и заполняем ID объекта\r\n\t\t\tthis.lastFilledObject[this.idName] = this.getID();\r\n\t\t}\r\n\t\t\r\n\t\t// Перебираем все поля ввода\r\n\t\tfor (let i = 0; i < elements.length; i++) {\r\n\t\t\t// console.dir(elements[i]);\r\n\t\t\t// Если элемент формы не имеет атрибута 'ignore'-- заполняем объект, если атрибут имеется -- игнорируем заполнения объекта\r\n\t\t\tif (elements[i].hasAttribute('ignore') == false) {\r\n\r\n\t\t\t\t// Если элемент типа \"select\" имеет атрибут \"multiple\" (Если присутствует множественный выбор)\r\n\t\t\t\tif (elements[i].type == \"select-multiple\") {\r\n\t\t\t\t\t\r\n\t\t\t\t\t// Перебираем в данном элементы все выбранные <option>\r\n\t\t\t\t\tfor (let k = 0; k < elements[i].selectedOptions.length; k++) {\r\n\r\n\t\t\t\t\t\t// и конкатенируем их в переменную \"accumulateValues\"\r\n\t\t\t\t\t\taccumulateValues += `${elements[i].selectedOptions[k].value}, \\n`;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// После этого создаем свойство в объекте и записываем результат конкатенации в это свойство.\r\n\t\t\t\t\tthis.lastFilledObject[elements[i].getAttribute(\"id\")] = accumulateValues;\r\n\r\n\t\t\t\t// Иначе просто создаем свойство у объекта с таким же именем, как и значение \"id\" в input\r\n\t\t\t\t}else{\r\n\t\t\t\t\tthis.lastFilledObject[elements[i].getAttribute(\"id\")] = elements[i].value;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t} \r\n\t\t}\r\n\r\n\t\t// Клонируем объект, чтобы метод смог его вернуть;\r\n\t\tfillableObject = Object.assign({},this.lastFilledObject)\r\n\t\treturn fillableObject;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод очищает все поля текущей формы.\r\n\t * @todo Передлелать этот метод через цикл \"forEach\" или \"for in \"\r\n\t * @return Ничего не возвращает\r\n\t */\r\n\r\n\tcleanInputs(){\r\n\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\r\n\t\t\t// Если поле скрытое, или элемент формы — кнопка, то пропускаем и не очищаем эти элементы\r\n\t\t\tif (!(this.currentForm.elements[i].type == \"hidden\" || this.currentForm.elements[i].localName == \"button\" )) {\r\n\t\t\t\tthis.currentForm.elements[i].value = \"\";\r\n\t\t\t\tthis.currentForm.elements[i].className = \"inputs-clean\" ;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Вариант1\r\n\t\t// for (const key in form.elements) {\r\n\t\t// \tif (form.elements.hasOwnProperty(key)) {\r\n\t\t// \t\tif (key.type != \"hidden\" || key.localName != \"button\") {\r\n\t\t// \t\t\tkey.value = \"\";\r\n\t\t// \t\t\tkey.className = \"inputs-clean\" \r\n\t\t// \t\t}\r\n\t\t// \t}\r\n\t\t// }\r\n\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Вариант2\r\n\t\t// form.elements.forEach(element => {\r\n\t\t// \tif (element.type != \"hidden\" || element.localName != \"button\") {\r\n\t\t// \t\telement.value = \"\";\r\n\t\t// \t\telement.className = \"inputs-clean\" \r\n\t\t// \t}\r\n\t\t// });\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод устанавливает, объект какого типа заполнятся в форме. Для работы метода в форме должно быть поле <input type='hidden' id='objtype' value=''>, иначе метод выбросит исключение.\r\n\t * @return {string} Возвращает тип объекта, который заполняется в текущую форму\r\n\t */\r\n\tgetObjectType(){\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\t\t\tif (this.currentForm.elements[i].id == \"objtype\") {\r\n\t\t\t\treturn this.currentForm.elements[i].value\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow \"Не найдено поле ввода  <input type='hidden'> с указанием типа объекта, который будет передан в базу данный. Добавьте в вашу форму поле <input type='hidden' id='objtype' value=''>  В поле value='' укажите тип объекта, который будет добавлен в базу данных\"\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод проверяет дубликаты объектов. В случае нахождения дубликата выводит сообщение.\r\n\t * @param {string} dublicateKey название поля объекта, по которобу будет происходить поиск дубликатов. \r\n\t * @return {boolean} true, если дубликат найден, false — если не нашел.\r\n\t */\r\n\tfindDublicate(dublicateKey = this.idName){\r\n\r\n\t\tlet flag;\r\n\r\n\t\tif (!(this.dataArray)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\t// Тут производится сравнение по полю \"dublicateKey\". Если есть совпадение — считается, что найден дубликат и метод выводит сообщение.\r\n\t\tflag = this.dataArray.some(item =>item[dublicateKey] == this.lastFilledObject[dublicateKey]);\r\n\t\tif (flag) {\r\n\t\t\talert (\"такая запись уже есть\");\r\n\t\t}\r\n\t\treturn flag;\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t//TODO Посмотреть метод validate\r\n\t/**\r\n\t * Метод проверяет форму на валидность (чтобы все необходимые поля были заполнены минимум 1 символом). \r\n\t * @return {boolean} \"true\", если все поля валидные. \"false\", если хотя-бы 1 поле не прошло проверку (тогда и форма считается не валидной)\r\n\t */\r\n\tvalidate() {\r\n\t\t\r\n\t\tlet counterOfInvalid = 0, // Счетчик полей, которые не прошли валидацию\r\n\t\t\telements = this.currentForm.elements; // Список элементов формы\r\n\r\n\t\tfor (let i = 0; i < elements.length; i++) {\r\n\r\n\t\t\tlet pattern \t = elements[i].dataset.pattern, // регуляр. выраж., по которому будет происходить проверка валидации.\r\n\t\t\t\tmessage \t = elements[i].dataset.message, // Сообщение, которое выводится в случае невалидности элемента\r\n\t\t\t\tboundId\t\t = elements[i].dataset.boundId, // id элемента, в который выводить сообщении\r\n\t\t\t\tboundElement = document.querySelector(`#${boundId}`), // элемент, в который будет выводится сообщение\r\n\t\t\t\tvalid \t\t = elements[i].value.search(pattern); // соответствие введеного значения -- паттерну\r\n\r\n\t\t\t// Валидацию будет проходить только тот элемент, у которого имеется свойство \"pattern\"\r\n\t\t\tif (pattern) {\r\n\r\n\t\t\t\tif (valid == -1) {\r\n\r\n\t\t\t\t\telements[i].className = \"inputs-invalid\"\r\n\r\n\t\t\t\t\tif (boundElement) boundElement.innerHTML = message;\r\n\t\t\t\t\r\n\t\t\t\t\tcounterOfInvalid++;\r\n\t\t\t\t}else{\r\n\t\t\t\t\telements[i].className = \"inputs-valid\"\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Если счетчик невалидных элементов больше нуля — то и сама форма невалидная (вернуть \"false\")\r\n\t\tif (counterOfInvalid > 0) {\r\n\t\t\treturn false;\r\n\t\t}else{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод перезаписывает Local Storage переданным в параметре объектом.\r\n\t * @param {Array} newArray новый массив данных, которым нужно перезаписать Local Storage\r\n\t * @return {Array} Возращает новый, перезаписанный массив с Local Storage\r\n\t */\r\n\toverwriteLocalStorage(newArray){\r\n\r\n\t\tif (this.needAddToLocalStorege) {\r\n\t\t\tlocalStorage.setItem(this.localStorageKey, JSON.stringify(newArray));\r\n\t\t\treturn JSON.parse(localStorage.getItem(this.localStorageKey))\r\n\t\t}else{ // Случай, если мы не работаем с localStorage, но метод был вызван.\r\n\t\t\tconsole.warn(`Свойство ${this}.needAddToLocalStorege в значении ${this.needAddToLocalStorege}. Не удалось записать в Local Storage`); \r\n\t\t\treturn newArray;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод  добавляет переданный в параметре объект -- в Local Storage.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\taddToDatabase(object = this.lastFilledObject) {\r\n\r\n\t\t// Добавляем переданный объект \"object\" в масиив данных \"this.dataArray\"\r\n\t\tthis.dataArray.push(object);\r\n\r\n\t\t// Перезаписываем LocalStorage\r\n\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который удаляет объект из базы данных, который был передан в параметре.\r\n\t * @param {object} object Объект, который необходимо удалить. По умолчанию \"this.selectedObject\"\r\n\t * @return {Array} Возвращает актуальный массив данных. (или false, если нет объекта для удаления)\r\n\t */\r\n\tdeleteObject(object = this.selectedObject){\r\n\t\t\r\n\t\tif (object) {\r\n\t\t\tthis.dataArray.splice(this.findObject(object), 1);\r\n\t\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t\t}else{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод, который изменяет объект в базе данных, который был передан в параметре.\r\n\t * @param {object} object Объект, который необходимо изменить. По умолчанию \"this.selectedObject\"\r\n\t * @return {Array} Возвращает актуальный массив данных. \r\n\t */\r\n\teditObject(object = this.selectedObject){\r\n\r\n\t\tlet copiedObject; // Переменная, чтобы склонировать объект \"this.lastFilledObject\"\r\n\t\t\r\n\t\tif (object) {\r\n\t\t\tthis.fillObject(object[this.idName])\r\n\r\n\t\t\t// Клонируем объект \"this.lastFilledObject\", для того, чтобы избавиться от копирования по ссылке.\r\n\t\t\tcopiedObject = Object.assign({},this.lastFilledObject)\r\n\r\n\t\t\tthis.dataArray[this.findObject(object)] = copiedObject; \r\n\t\t\treturn this.overwriteLocalStorage(this.dataArray);\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод находит индекс переданного в параметре объекта в текущем массиве данных (dataArray)\r\n\t * @param {object} object Объект, который нужно найти в массиве данных.\r\n\t * @return {number} Возвращает индекс объекта, который был передан в параметр.\r\n\t */\r\n\tfindObject(object){\r\n\r\n\t\treturn  this.dataArray.findIndex((item)=>{\r\n\t\t\t// Если совпадают значения \"id\" в переданном объекте и в массиве данных -- возращаем индекс. \r\n\t\t\treturn item[this.idName] == object[this.idName]\r\n\t\t})\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t *  Метод формирует уникальный идентификатор для нового объекта.\r\n\t * @return {number} Возращает новое значение \"id\", которого еще не было (самое большое текущее \"id\" +1)\r\n\t */\r\n\tgetID() {\r\n\r\n\t\tlet currentId = 0; // Текущий \"id\"\r\n\r\n\t\t// Если у нас присудствует массив с данными, то...\r\n\t\tif (this.dataArray) {\r\n\t\t\t// ...ищем самое большое значение \"id\"\r\n\t\t\tthis.dataArray.forEach(element => {\r\n\t\t\t\t\r\n\t\t\t\tif( parseInt(element[this.idName])  > currentId){\r\n\t\t\t\t\tcurrentId  = parseInt(element[this.idName])\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\t// И возвращаем на 1 больше\r\n\t\t\treturn currentId + 1;\r\n\r\n\t\t// Если данных нет -- возвращаем просто 1 (предпологается что это запрос перед созданием массива с данными)\r\n\t\t}else{\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * Метод формирует ключ для LocalStorage.\r\n\t * @param {string} postfix Постфикс (Часть, которая указывается в названии ключа после типа объекта для создания имени ключа LocalStorage (по умолчанию \"-library\"))\r\n\t * @return {string} Возвращает созданный ключ для LocalStorage.\r\n\t */\r\n\tgetLocalStorageKey(postfix = \"-library\"){\r\n\r\n\t\t//Находим в форме поле ввода с id == \"objtype\" (это поле типа  \"hidden\")\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\t\t\tif (this.currentForm.elements[i].id == \"objtype\") {\r\n\t\t\t\t\r\n\t\t\t\t// Возвращаем созданный  ключ\r\n\t\t\t\treturn this.currentForm.elements[i].value + postfix;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow \"Метод не смог найти поле с id == 'objtype' и value == '<название вашего объекта>'. Убедитесь что оно есть \"\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\r\n\t/**\r\n\t * Метод находит поле для ввода, у которого есть привязка к данным в базе данных и заполняет данными.\r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tcheckForm(){\r\n\r\n\t\tlet localStorageKeyBind,\r\n\t\t\tobjectPropertyBind ,\r\n\t\t\tarrayOfObjects;\r\n\r\n\t\t// Перебираем все элементы формы\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\r\n\t\t\tlocalStorageKeyBind = this.currentForm.elements[i].dataset.localStorageKeyBind;\r\n\t\t\tobjectPropertyBind = this.currentForm.elements[i].dataset.objectPropertyBind;\r\n\t\t\tarrayOfObjects = JSON.parse(window.localStorage.getItem(localStorageKeyBind));\r\n\r\n\t\t\t// Если перебираемое поле для ввода содержит какую -либо из привязок -- тогда заполняем это поле объектами \r\n\t\t\tif (localStorageKeyBind && objectPropertyBind) {\r\n\t\t\t\tthis.fillInput(this.currentForm.elements[i], arrayOfObjects);\r\n\r\n\t\t\t// Если пользователь привязал что-то одно (из двух необходимых атрибутов) -- выбрасываем исключение\r\n\t\t\t} else if(localStorageKeyBind){\r\n\t\t\t\tthrow \"Нет привязки к свойству объекта. Укажите в HTML элементе атрибут <objectPropertyBind> со значением свойства объекта, которое необходимо выводить.\"\r\n\t\t\t} else if(objectPropertyBind){\r\n\t\t\t\tthrow \"Нет привязки к Массиву объектов в LocalStorage. Укажите атрибут <localStorageKeyBind> со значением ключа, из которого необходимо получить данные для привязки.\"\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n// --------------------------------------------------------------------------\r\n\t/**\r\n\t * Метод заполняет элемент формы значениями с массива.\r\n\t * @param {object} element Елемент формы, который необходимо заполнить\r\n\t * @param {Array} arrayOfObjects Массив объектов, из которых нужно взять необходимое значение\r\n\t * @return {object} возвращает заполненный элемент\r\n\t */\r\n\tfillInput(element, arrayOfObjects){\r\n\r\n\t\tlet bindingKey = element.dataset.objectPropertyBind; // Свойство объекта, из которого необходимо взять значение и заполнить в элемент.\r\n\t\tlet elementType = element.tagName.toLowerCase(); // Тип  DOM-элемента\r\n\r\n\t\tif (arrayOfObjects) {\r\n\t\t\tswitch (elementType) {\r\n\r\n\t\t\t\t// пока метод реализован только чтобы заполнять <select> \r\n\t\t\t\tcase \"select\":\r\n\t\t\t\t\tfor (let i = 0; i < arrayOfObjects.length; i++) {\r\n\t\t\t\t\t\tlet optionElement = document.createElement(\"option\");\r\n\r\n\t\t\t\t\t\toptionElement.value = arrayOfObjects[i][bindingKey];\r\n\t\t\t\t\t\toptionElement.innerHTML = arrayOfObjects[i][bindingKey];\r\n\t\t\t\t\t\telement.appendChild(optionElement);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn element;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\treturn false;\r\n\t\t}\t\r\n\t}\r\n\r\n\t/**\r\n\t * Метод заполняет поля текущей формы (всей формы) значениями из объекта\r\n\t * @param {object} fillingObject Объект для заполнения формы. \r\n\t * @return {void} Ничего не возвращает\r\n\t */\r\n\tfillForm(fillingObject){\r\n\r\n\t\t// Перебираем все элементы формы\r\n\t\tfor (let i = 0; i < this.currentForm.elements.length; i++) {\r\n\r\n\t\t\t// Если поле не скрытое, или элемент формы — не кнопка\r\n\t\t\tif (!(this.currentForm.elements[i].type == \"hidden\" || this.currentForm.elements[i].localName == \"button\" )) {\r\n\r\n\t\t\t\t// перебираем все свойства объекта \"fillingObject\"\r\n\t\t\t\tfor (const key in fillingObject) {\r\n\r\n\t\t\t\t\t// Если название свойства объекта соответсвует значению \"id\" в input-те\r\n\t\t\t\t\tif (key == this.currentForm.elements[i].id){\r\n\r\n\t\t\t\t\t\t// тогда заполняем поле значением со свойсва объекта.\r\n\t\t\t\t\t\tthis.currentForm.elements[i].value = fillingObject[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nclass Book{\r\n\t// Конструктор не применялся. Новый объект \"book\" заполняется с помощью цикла\r\n/* \tconstructor(id, name, author){\r\n\t\tthis.id = id;\r\n\t\tthis.name = name;\r\n\t\tthis.author = author;\r\n\r\n\t} */\r\n\r\n\t// constructor(array){\r\n\r\n\t// \tfor (let i = 0; i < array.length; i++) {\r\n\t\t\t\r\n\t// \t}\r\n\t// \t// array.forEach(element => {\r\n\t// \t// \telement.id = id;\r\n\t// \t// \telement.name = name;\r\n\t// \t// \telement.author = author;\r\n\t// \t// });\r\n\t// }\r\n\r\n}\r\n\r\nexport {Book};","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nexport class Genre{\r\n}\r\n","/**\r\n * Класс для создания объектов \"Книги\". Каждая книга — объект, свойства которого пользователь заполняет в полях \"input\" в форме \"Добавить книгу\"\r\n */\r\nexport class Author{\r\n}\r\n","import { $ } from './myHelperLib.js';\r\nimport { Table } from './table.class';\r\nimport { Form } from './form.class';\r\nimport './css/style1.css';\r\nimport \"bootstrap/dist/css/bootstrap.min.css\"\r\n\r\nwindow.addEventListener(\"load\", ()=>{\r\n\r\n\tlet formGenre = new Form(document.forms[0], \"id\");\r\n\tlet tableGenre = new Table('#table-genres',formGenre);\r\n\r\n\tformGenre.checkForm();\r\n\ttableGenre.addObservers(tableGenre, formGenre);\r\n\ttableGenre.fillTable();\r\n\r\n\t// ОБРАБОТЧИК КНОПКИ \"add\"\r\n\t$('#add').addEventListener(\"click\", function() {\r\n\r\n\t\tlet returnedObject = formGenre.addButtonHandler();\r\n\r\n\t\tif (returnedObject == false) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\ttableGenre.addRows(returnedObject);\r\n\t\ttableGenre.notify(); \r\n   });\r\n\r\n    // ОБРАБОТЧИК КНОПКИ \"edit\"\r\n\t$('#edit').addEventListener(\"click\", function() {\r\n\r\n\t\tlet newArray = formGenre.editObject();\r\n\t\tif (newArray) {\r\n\t\t\ttableGenre.cleanTable();\r\n\t\t\ttableGenre.tableData = newArray;\r\n\t\t\ttableGenre.notify()\r\n\t\t\ttableGenre.fillTable();\r\n\t\t}else{\r\n\t\t\talert(\"Какую строку вы хотите изменить? Пожалуйста выберите строку.\")\r\n\t\t}\r\n\t});\r\n\r\n\t// ОБРАБОТЧИК КНОПКИ \"delete\"\r\n\t$('#delete').addEventListener(\"click\", function() {\r\n\r\n\t\tlet newArray = formGenre.deleteObject();\r\n\t\tif (newArray) {\r\n\t\t\ttableGenre.cleanTable();\r\n\t\t\ttableGenre.tableData = newArray;\r\n\t\t\ttableGenre.notify()\r\n\t\t\ttableGenre.fillTable();\r\n\t\t}else{\r\n\t\t\talert(\"Нечего удалять. Выберите пожалуйста строку.\")\r\n\t\t}\r\n\t});\r\n\r\n\t// ОБРАБОТЧИК КНОПКИ \"clearInputs\"\r\n\t$('#cleanInputs').addEventListener(\"click\", function() {\r\n\r\n\t\tformGenre.cleanInputs();\r\n\t\t\r\n\t});\r\n\r\n   \t// ОБРАБОТЧИК ПОИСКА\r\n\t$('#input-search').addEventListener(\"keyup\", (e)=>{\r\n\r\n\t\t// Очищаем текущую таблицу\r\n\t\ttableGenre.cleanTable();\r\n\r\n\t\t// Заполняем таблицу тем массивам, который возвращает фун-я \"tableWorker.search\". Возращаем массив с данными.\r\n\t\ttableGenre.tableData = tableGenre.search(e.target, e.target.dataset.searchObjectProperty);\r\n\t\ttableGenre.notify()\r\n\t\ttableGenre.fillTable()\r\n\t})\r\n\r\n\t// ОБРАБОТЧИК ВЫБОРА СТРОК \r\n\ttableGenre.tableClickHandler()\r\n\r\n})"],"sourceRoot":""}